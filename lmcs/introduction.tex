\section{Introduction}
Session types~\cite{honda93,takeuchihonda94,hondavasconcelos98} are a type formalism that ensures \emph{communication channels} are used according to their protocols, much like, \eg, data types ensure that functions are used according to their signature. Session types have been studied in many settings. Most notably, they have been defined for the $\pi$-calculus~\cite{honda93,takeuchihonda94,hondavasconcelos98}, a foundational calculus for communication and concurrency, and the concurrent $\lambda$-calculi~\cite{gayvasconcelos10}, including the main focus of our paper: Good Variation~\cite[GV]{wadler15,lindleymorris15}.

GV is a concurrent $\lambda$-calculus with \emph{binary} session types, where each channel is shared between exactly two processes. Binary session types guarantee two crucial properties: \emph{communication safety}---\eg, if the protocol says to transmit an integer, you transmit an integer---and \emph{session fidelity}---\eg, if the protocol says send, you send. A third crucial property is \emph{deadlock freedom}, which ensures that processes do not have cyclic dependencies---\eg, when two processes wait for each other to send a value. Binary session types \emph{alone} are insufficient to rule out deadlocks arising from interleaved sessions, but several additional techniques have been developed to guarantee deadlock freedom in session-typed $\pi$-calculus and concurrent $\lambda$-calculus.

In the $\pi$-calculus literature, there have been several attempts at developing Curry-Howard correspondences between session-typed $\pi$-calculus and linear logic~\cite{girard87}: Caires and Pfenning's $\pi$DILL~\cite{cairespfenning10} corresponds to dual intuitionistic linear logic~\cite{barber96}, and Wadler's Classical Processes~\cite[CP]{wadler14} corresponds to classical linear logic~\cite[CLL]{girard87}. Both calculi guarantee deadlock freedom, which they achieve by the combination of binary session types with a restriction on the way processes can be connected by channels: two processes can share at most one channel, and, more generally, information transmitted between any two processes must pass through one \emph{unique} series of channels and intermediate processes. This property follows from a syntactic restriction: the combination of name restriction and parallel composition into a single construct, corresponding to the logical cut.

There are many downsides to combining name restriction and parallel composition, such as lack of modularity, difficulty typing structural congruence and formulating label-transition semantics, which have led to various approaches to decoupling these constructs. Hypersequent CP~\cite{MP18,kokkemontesi19popl,kokkemontesi19tlla} and Linear Compositional Choreographies~\cite{CarboneMS18} decouple them, but maintain the correspondence to linear logic and allow only tree-structured processes. Priority CP~\cite[PCP]{dardhagay18extended} weakens the correspondence to CLL in exchange for a more expressive language which allows cyclic-structured processes. PCP decouples CP's cut rule into two separate constructs: one for parallel composition via a mix rule, and one for name restriction via a cycle rule. To restore deadlock freedom, PCP uses \emph{priorities}~\cite{kobayashi06,padovani14}. Priorities encode the \emph{order of actions} and rule out bad cyclic interleavings. Dardha and Gay~\cite{dardhagay18extended} prove cycle-elimination for PCP, adapting the cut-elimination proof for classical linear logic, and deadlock freedom follows as a corollary.

CP and GV are related via a pair of translations which satisfy simulation~\cite{lindleymorris16}, and which can be tweaked to satisfy operational correspondence. The two calculi share the same strong guarantees. GV achieves deadlock freedom via a similar syntactic restriction: it combines channel creation and thread spawning into a single operation, called ``fork'', which is related to the cut construct in CP. Unfortunately, as with CP, this syntactic restriction has its downsides.

Our aim is to develop a more expressive version of GV while maintaining deadlock freedom. While process calculi have their advantages, \eg, their succinctness compared to concurrent $\lambda$-calculi, we chose to work with GV for several reasons. In general, concurrent $\lambda$-calculi support higher-order functions, and have a capability for abstraction not usually present in process calculi. Within a concurrent $\lambda$-calculus, one can derive extensions of the communication capabilities of the language via well-understood extensions of the functional fragment, \eg, we can derive internal/external choice from sum types. Concurrent $\lambda$-calculi maintain a clear separation between the program which the user writes and the configurations which represent the state of the system as it evaluates the program. However, our main motivation is that results obtained for $\lambda$-calculi transfer more easily to real-world functional programming languages. Case in point: we easily adapted the type system of PGV to Linear Haskell~\cite{bernardyboespflug18}, which gives us a library for deadlock-free session-typed programming~\cite{kokkedardha21hs}.
The benefit of working specifically with GV, as opposed to other concurrent $\lambda$-calculi, is its relation to CP~\cite{wadler14}, and its formal properties, including deadlock freedom.

We thus pose our research question for GV:

\vspace{1em}
  \textbf{RQ:}
  \emph{Can we design a more expressive GV which guarantees deadlock freedom for cyclic-structured processes?}
\vspace{1em}

We follow the line of work from CP to Priority CP, and present Priority GV (PGV), a~variant of GV which decouples channel creation from thread spawning, thus allowing cyclic-structured processes, but which nonetheless guarantees deadlock freedom via priorities. This closes the circle of the connection between CP and GV~\cite{wadler14}, and their priority-based versions, PCP~\cite{dardhagay18extended} and PGV.

We make the following main contributions:
\begin{enumerate}
\item \textbf{Priority GV}. We present Priority GV (\cref{sec:pgv}, PGV), a session-typed functional language with priorities, and prove \emph{subject reduction} (\cref{thm:pgv-subject-reduction-confs}) and \emph{progress} (\cref{thm:pgv-closed-progress-confs}).

We addresses several problems in the original GV language, most notably:
  \begin{enumerate}
  \item PGV does not require the pseudo-type $S^\sharp$;
  \item Structural congruence is type preserving.
  \end{enumerate}
  PGV answers our research question positively as it allows cyclic-structured binary session-typed processes that are deadlock free.
\item \textbf{Translation from PCP to PGV}.
  We present a \emph{sound and complete encoding} of PCP~\cite{dardhagay18extended} in PGV (\cref{sec:pcp}). We prove the encoding preserves typing (\cref{thm:pcp-to-pgv-confs-preservation}) and satisfies operational correspondence (\cref{thm:pcp-to-pgv-operational-correspondence-soundness,thm:pcp-to-pgv-operational-correspondence-completeness}).

  To obtain a tight correspondence, we update PCP, moving away from commuting conversions and reduction as cut elimination towards reduction based on structural congruence, as it is standard in process calculi.
\end{enumerate}

This paper is an improved and extended version of a paper published at FORTE 2021 international conference \cite{kokkedardha21pgv}. We present detailed examples and complete proofs of our technical results.
