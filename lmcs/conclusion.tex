\section{Related Work and Conclusion}
\usingnamespace{pcp}

\subsubsection*{Deadlock freedom and progress}
Deadlock freedom and progress are well studied properties in the $\pi$-calculus.
For the ``standard'' typed $\pi$-calculus---types for channels used in input and output, an important line of work stems from Kobayashi's approach to deadlock freedom~\cite{kobayashi98}, where priorities are values from an abstract poset. Kobayashi~\cite{kobayashi06} simplifies the abstract poset to pairs of naturals, called \emph{obligations} and \emph{capabilities}. Padovani simplifies these further to a single natural, called a \emph{priority}~\cite{padovani14}, and adapts obligations/capabilities to session types~\cite{padovani13}. Later work by Kobayashi and co-authors \cite{GiachinoKL14,kobayashilaneve17} address deadlock detection for a value-passing CCS (a predecessor of the $\pi$-calculus) where the number of nodes in a network is arbitrary, namely modelling unbounded networks. The authors define a sound inference algorithm for their type system, which guarantees deadlock freedom for these more complex kinds of communication networks. This type system is more expressive than previous work by Kobayashi.

For the session-typed $\pi$-calculus, an important line of work stems from Dezani and co-authors. In their work, Dezani~\etal~\cite{dezani-ciancaglinimostrous06} guarantee progress by allowing only one active session at a time. As sessions do not interleave, consequently they do not deadlock. Later on, Dezani \etal~\cite{dezani-ciancagliniliguoro09progress} introduce a partial order on channels, similar to Kobayashi~\cite{kobayashi98} and produce a type system for progress.

Carbone and Debois~\cite{carbonedebois10} define progress for session-typed $\pi$-calculus in terms of a \emph{catalyser}, which provides the missing counterpart to a process. Intuitively,  either the process is deadlock-free in which case the catalyser is structurally congruent to the inaction process, or if the process is ``stuck'' for \eg, an input process $\tm{\recv{x}{y}{\halt}}$ (using CP syntax) then the catalyser simply provides the missing output required for communication. Carbone~\etal~\cite{carbonedardha14} use catalysers to show that progress is a compositional form of livelock freedom and can be lifted to session types via the encoding of session types to linear types~\cite{kobayashi07,dardhagiachino12,dardha14beat,dardhaetal17}. In this work, Carbone \etal \cite{carbonedardha14} sistematise and compare different notions of liveness properties: progress, deadlock freedom and livelock freedom. Their technique of using the encoding of session types combined with Kobayashi's type systems for deadlock and livelock freedom allows for a more flexible deadlock/livelock detection. It is worth noting that livelock freedom is a stronger property than deadlock freedom in the presence of recursion, as the former also discards useless divergent processes; for finite processes the two properties coincide.

Vieira and Vasconcelos~\cite{vieiravasconcelos13} use single priorities and an abstract partial order to guarantee deadlock freedom in a binary session-typed $\pi$-calculus and building on conversation types, which is akin to session types.

While our work focuses on {binary} session types, it is worth discussing related work on Multiparty Session Types (MPST), which describe communication among multiple agents in a distributed setting. The line of work on MPST starts with Honda~\etal~\cite{hondayoshida08}, which guarantees deadlock freedom {within a single session} by design, but the property does not hold for session interleaving.
Bettini~\etal~\cite{bettinicoppo08} follow a technique similar to Kobayashi's for MPST.
The main difference with our work is that we associate priorities with communication actions, where Bettini~\etal~\cite{bettinicoppo08} associate them with channels.
Coppo \etal \cite{coppoetal13,coppoetal16} present a deterministic, sound and complete, and compositional type inference algorithm for an \emph{interaction type system}, which is used to guarantee global progress for processes in a calculus based on asynchronous as well as dynamically interleaved and interfered multiparty sessions. The interaction type system allows to infer \emph{causalities}---much in the line of Kobayashi's priorities ---of channels, thus guaranteeing that session-typed processes do not get stuck at intermediate stages of their sessions.
Carbone and Montesi~\cite{carbonemontesi13} combine MPST with choreographic programming and obtain a formalism that satisfies deadlock freedom. In the same vein as MPST, choreographic programming specifies communication among all participants in a distributed system. While MPST target mainly protocol descriptions, choreographies have mainly targetted implementations and programming languages as they are suitable for describing concrete system implementations.
Deni\'{e}lou and Yoshida~\cite{DenielouY13} introduce \emph{multiparty compatibility}, which generalises the notion of duality in binary session types. They synthesise safe and deadlock-free \emph{global types}--specifying communication among {all} involved participants, from \emph{local session types}--specifying communication from the viewpoint of {one} participant. To do so, they leverage Labelled Transition Systems (LTSs) and communicating automata.
Castellani~\etal~\cite{CastellaniDGH20} guarantee livelock freedom, a stronger property than deadlock freedom, for MPST with {internal delegation}, where participants in the same session are allowed to delegate tasks to each other, and internal delegation is captured by the global type.
Scalas and Yoshida~\cite{scalasyoshida19} provide a revision of the foundations for MPST, and offer a less complicated and more general theory, by removing duality/consistency. The type systems is parametric and type checking is decidable, but allows for a novel integration of model checking techniques. More protocols and processes can be typed and are guaranteed to be free of deadlocks.


Neubauer and Thiemann~\cite{neubauert04} and Vasconcelos~\etal~\cite{vasconcelosravara04,vasconcelosgay06} introduce the first functional language with session types. Such works did not guarantee deadlock freedom until GV~\cite{lindleymorris15,wadler14}.
Toninho~\etal~\cite{toninhocaires12} present a translation of simply-typed $\lambda$-calculus into session-typed $\pi$-calculus, but their focus is not on deadlock freedom.
Fowler \etal \cite{fowleretal21} present Hypersequent GV (HGV), which is a variation of GV that uses hyper-environments, much in the same line as Hypersequent CP, and enjoys deadlock freedom, confluence, and strong normalisation.

\subsubsection*{Ties with logic}
The correspondence between logic and types lays the foundation for functional programming~\cite{wadler15}.
Since its inception by Girard~\cite{girard87}, linear logic has been a candidate for a foundational correspondence for concurrent programs.
A~correspondence with linear $\pi$-calculus was established early on by Abramsky~\cite{abramsky94} and Bellin and Scott~\cite{bellinscott94}. Many years later, several correspondences between linear logic and the $\pi$-calculus with binary session types were proposed. Caires and Pfenning~\cite{cairespfenning10} propose a correspondence with dual intuitionistic linear logic, while Wadler~\cite{wadler12} proposes a correspondence with classical linear logic. Both works guarantee deadlock freedom as a consequence of adopting cut elimination.
Building on a previous work \cite{cairespfenning10}, Toninho \etal \cite{toninhoetal13} present a Curry-Howard correspondence between session types and linear logic for functional language via linear contextual monads, which are first-class values, thus giving rise to a higher-order session-typed  language. In addition to the more standard results, the authors also prove a global progress theorem.
Dardha and Gay~\cite{dardhagay18extended} define Priority CP by integrating Kobayashi and Padovani's work on priorities~\cite{kobayashi06,padovani14} with CP, weakening its ties to linear logic in exchange for expressivity. However, they show how PCP can be also {viewed as} a an extension of linear logic, which they call Priority Linear Logic (PLL), and uses mix and cycle rules as opposed to the cut rule.
Dardha and P\'{e}rez~\cite{dardhaperez15extended,dardhaperez15,DardhaP22} compare priorities \`a la Kobayashi with tree restrictions \`a la CP, and show that the latter is a subsystem of the former. In addition, they give a detailed account of comparing several type systems for deadlock freedom spanning across session types, linear logic, and linear types.
Carbone~\etal~\cite{CarboneMSY15,carbonelindley16} give a logical view of MPST with a generalised duality.
Caires and P\'{e}rez~\cite{CairesP16} give a presentation of MPST in terms of binary session types and the use of a \emph{medium process} which guarantee protocol fidelity and deadlock freedom. Their binary session types are rooted in linear logic.
Ciobanu and Horne~\cite{CiobanuH15} give the first Curry-Howard correspondence between MPST and BV~\cite{Guglielmi07}, a conservative extension of linear logic with a non-commutative operator for sequencing.
Horne~\cite{Horne20} give a system for subtyping and multiparty compatibility where compatible processes are race free and deadlock free using a Curry-Howard correspondence, similar to the approach in~\cite{CiobanuH15}.
Balzer~\etal~\cite{balzerpfenning17} introduce sharing at the cost of deadlock freedom, which they restore using \emph{worlds}, an approach similar to priorities~\cite{balzertoninho19}.
Staying on sharing, Rocha and Caires \cite{rochacaires21} introduce an imperative feature, that of shared mutable states into a functional language based on Curry-Howard correspondence with linear logic. Their type system is thus able to capture programs which were not possible in previous works. The authors prove extensive technical results, including session fidelity, progress, confluence and
normalisation.
Lastly, Jacobs \etal \cite{JacobsBK22a} present a novel technique to guarantee deadlock freedom based on the notion of connectivity graph, which is an abstract representation of the topology of concurrent systems, and separation logic used to substructurally treat connectivity graph edges and labels.


\subsubsection*{Conclusion and Future Work}
We answered our research question by presenting Priority GV, a~session-typed functional language which allows cyclic communication structures and uses priorities to ensure deadlock freedom. We showed its relation to Priority CP~\cite{dardhagay18extended} via an operational correspondence.

Our formalism so far only captures the core of GV. In future work, we plan to explore recursion, following Lindley and Morris~\cite{lindleymorris16} and Padovani and Novara~\cite{padovaninovara15}, and sharing, following Balzer and Pfenning~\cite{balzerpfenning17} or Voinea~\etal~\cite{VoineaDG19}.

\subsubsection*{Acknowledgements}
The authors would like to thank the anonymous reviewers for their detailed feedback, which helped produce a more complete and polished work.
Also, the authors would like to thank Simon Fowler, April Gon\c{c}alves, and Philip Wadler for their comments on the manuscript.
