% !TeX root = priorities.tex
\documentclass[main.tex]{subfiles}

\begin{document}

\section{Priority GV}\label{sec:pgv}
\usingnamespace{pgv}

We present Priority GV (PGV), a session-typed functional language based on GV~\cite{wadler15,lindleymorris15} which uses priorities \`{a} la Kobayashi~\cite{kobayashi06,padovaninovara15} to enforce deadlock freedom.
%The separation of channel creation and thread spawning in GV only allows tree-shaped communication structures, so it is trivially free from cycles, and therefore deadlocks. For e.g., if some term $\tm{L}$ has the means to communicate with both $\tm{M}$ and $\tm{N}$, then $\tm{M}$ and $\tm{N}$ cannot communicate amongst themselves. However, as with CP, this rules out \emph{all} cyclic communication structures, not just those with deadlocks.
Priority GV offers a more fine-grained analysis of communication structures, and by separating channel creation form thread spawning it allows cyclic structures. We illustrate PGV with Milner's cyclic scheduler~\cite{milner89}.

\begin{example}[Milner's Cyclic Scheduler in PGV]\label{sec:pgv-example}
Suppose a set of processes $\tm{\proc{i}}$, $1\leq{i}\leq{n}$, is scheduled to perform some tasks in cyclic order, starting with $\tm{\proc0}$, ending with $\tm{\proc{n}}$, and notifying $\tm{\proc0}$ when all processes have finished.
% The dotted lines represent the optional transfer of data between processes. With three processes, the scheduler looks as follows:\simon{Sorry, I found this diagram super confusing\dots Is there any way you could make it look more cyclic? Also, have the convention of a single annotation per channel, with the convention that the greater agent / proc gets the primed end of the previous channel?}
% \input{fig/pgv-scheduler.tex}
We implement the scheduler as follows, using $\tm{\prod_{i}\conf{C}_i}$ to denote the parallel composition of the processes $\tm{\conf{C}_i}$, and $\tm{\plug{M}{N}}$ to denote the plugging of $\tm{N}$ in the one-hole term-context $\tm{M}$:
\[
  \begin{array}{lrlr}
    \tm{\sched}
    & \defeq & \tm{\res{a_1}{a'_1}{\dots{\res{a_n}{a'_n}{}}}}
               \tm{\res{b_1}{b'_1}{\dots{\res{b_n}{b'_n}{}}}}
               \tm{\res{c_1}{c'_1}{\dots{\res{c_n}{c'_n}{}}}}
               \tm{\res{d}{d'}{}}
    \\ &     & \tm{\begin{array}{lll}
                     (
                     & \phi\;\proc1
                     \parallel
                     \child\;\andthen{\agent1}{\andthen{\wait\;{c'_3}}{\close\;{d}}}
                     \\
                     \parallel
                     &
                     \prod_{2\leq{i}\leq{n}}
                     (\child\;\proc{i} \parallel \child\;\andthen{\wait\;{c'_{i-1}}}{\agent{i}})
                     & )
                   \end{array}}
    \\
    \tm{\agent{i}}
    & \defeq & \tm{\andthen{\close\;{a_i}}{\andthen{\wait\;{b_i}}{\close\;{c_i}}}}
    \\
    \tm{\proc{i}}
    & \defeq & \tm{\andthen{\wait\;{a'_i}}{\plug{M_i}{\andthen{\close\;{b'_i}}{N_i}}}}
  \end{array}
\]
Our scheduler $\tm{\sched}$ consists of set of agents $\tm{\agent{i}}$, $1\leq{i}\leq{n}$, each representing their respective process. Each process $\tm{\proc{i}}$ waits for the signal to start their task on $\tm{a'_i}$, and signals completion on $\tm{b'_i}$. Each agent signals their process to start on $\tm{a_i}$, waits for their process to finish on $\tm{b_i}$, and then signals for the next agent to continue on $\tm{c_i}$. The agent $\tm{\agent0}$ initiates, then waits for every other process to finish, and signals $\tm{\proc0}$ on $\tm{d}$. Every other agent $\tm{\agent{i}}$, $2\leq{i}\leq{n}$ waits on $\tm{c'_{i-1}}$ for the signal to start.
Each of the channels in the scheduler is of a terminated type, and is merely used to synchronise.
For simplicity, we let $\tm{\sched}$ be a configuration. However, we could equivalently have represented it as a function which takes three processes as arguments, and creates this configuration.
\end{example}

\subsubsection*{Session types}
Session ($\ty{S}$) types are defined by the following grammar:
\[
\begin{array}{lcl}
  \ty{S}
  & \Coloneqq & \ty{\tysend[\cs{o}]{T}{S}}
    \sep        \ty{\tyrecv[\cs{o}]{T}{S}}
    \sep        \ty{\tyends[\cs{o}]}
    \sep        \ty{\tyendr[\cs{o}]}
\end{array}
\]
The session types $\ty{\tysend[\cs{o}]{T}{S}}$ and $\ty{\tyrecv[\cs{o}]{T}{S}}$ describe the endpoints of a channel over which we send or receive a value of type $\ty{T}$, and then proceed as $\ty{S}$. The types $\ty{\tyends[\cs{o}]}$ and $\ty{\tyendr[\cs{o}]}$ describe endpoints of a channel whose communication has finished, and over which we must synchronise before closing the channel. Each connective in a session type is annotated with a \emph{priority} $\cs{o}\in\mathbb{N}$.

\subsubsection*{Types}
Types ($\ty{T}$, $\ty{U}$) are defined by the following grammar:
\[
\begin{array}{lcl}
  \ty{T}, \ty{U}
  & \Coloneqq & \ty{\typrod{T}{U}}
    \sep        \ty{\tyunit}
    \sep        \ty{\tysum{T}{U}}
    \sep        \ty{\tyvoid}
    \sep        \ty{\tylolli[\cs{p},\cs{q}]{T}{U}}
    \sep        \ty{S}
\end{array}
\]
The types $\ty{\typrod{T}{U}}$, $\ty{\tyunit}$, $\ty{\tysum{T}{U}}$, and $\ty{\tyvoid}$ are the standard linear $\lambda$-calculus product type, unit type, sum type, and empty type.
The type $\ty{\tylolli[\cs{p},\cs{q}]{T}{U}}$ is the standard linear function type, annotated with \emph{priority bounds} $\cs{p},\cs{q}\in\mathbb{N}\cup\{\cs{\pbot},\cs{\ptop}\}$.
Every session type is also a type.

Given a function with type $\ty{\tylolli[\cs{p},\cs{q}]{T}{U}}$, $\cs{p}$ is a \emph{lower bound} on the priorities of the endpoints captured by the body of the function, and $\cs{q}$ is an \emph{upper bound} on the priority of the communications that take place as a result of applying the function. The type of \emph{pure functions} $\ty{\tylolli{T}{U}}$, \ie those which perform no communications, is syntactic sugar for $\ty{\tylolli[\cs{\ptop},\cs{\pbot}]{T}{U}}$.

\subsubsection*{Environments}
Typing environments $\ty{\Gamma}$, $\ty{\Delta}$ associate names to types. Environments are linear, so two environments can only be combined as $\ty{\Gamma}, \ty{\Delta}$ if their names are distinct, \ie $\fv(\ty{\Gamma})\cap\fv(\ty{\Delta})=\varnothing$.
\[
\begin{array}{lcl}
  \ty{\Gamma}, \ty{\Delta}
  & \Coloneqq & \ty{\emptyenv}
    \sep        \ty{\Gamma}, \tmty{x}{T}
\end{array}
\]

\subsubsection*{Duality}
Duality plays a crucial role in session types. The two endpoints of a channel are assigned dual types, which ensures that, for instance, whenever one program \emph{sends} a value on a channel, the program on the other end is waiting to \emph{receive}. Each session type $\ty{S}$ has a dual, written $\ty{\co{S}}$. Duality is an involutive function which preserves priorities.
\[
  \ty{\co{\tysend[\cs{o}]{T}{S}}} = \ty{\tyrecv[\cs{o}]{T}{\co{S}}}
  \qquad
  \ty{\co{\tyrecv[\cs{o}]{T}{S}}} = \ty{\tysend[\cs{o}]{T}{\co{S}}}
  \qquad
  \ty{\co{\tyends[\cs{o}]}} = \ty{\co{\tyendr[\cs{o}]}}
  \qquad
  \ty{\co{\tyendr[\cs{o}]}} = \ty{\co{\tyends[\cs{o}]}}
\]

\subsubsection*{Priorities}
The function $\pr$ returns the smallest priority of a session type. The type system guarantees that the top-most connective always holds the smallest priority, so we simply return the priority of the top-most connective:
\[
  \pr(\ty{\tysend[\cs{o}]{T}{S}}) = \cs{o}
  \qquad
  \pr(\ty{\tyrecv[\cs{o}]{T}{S}}) = \cs{o}
  \qquad
  \pr(\ty{\tyends[\cs{o}]})       = \cs{o}
  \qquad
  \pr(\ty{\tyendr[\cs{o}]})       = \cs{o}
\]
We extend the function $\pr$ to types and typing contexts by returning the smallest priority in the type or context, or $\cs{\top}$ if there is no priority. We use $\sqcap$ and $\sqcup$ to denote the minimum and maximum:
\[
\begin{array}{lcl}
  \minpr(\ty{\typrod{T}{U}})                 & = & \minpr({\ty{T}})\sqcap\minpr({\ty{U}}) \\
  \minpr(\ty{\tysum{T}{U}})                  & = & \minpr({\ty{T}})\sqcap\minpr({\ty{U}}) \\
  \minpr(\ty{\tylolli[\cs{p},\cs{q}]{T}{U}}) & = & \cs{p} \\
  \minpr(\ty{\Gamma}, \tmty{x}{A})           & = & \minpr(\ty{\Gamma})\sqcap\pr(\ty{A})
\end{array}
\qquad
\begin{array}{lcl}
  \minpr(\ty{\tyunit})                       & = & \ptop \\
  \minpr(\ty{\tyvoid})                       & = & \ptop \\
  \minpr(\ty{S})                             & = & \pr(\ty{S}) \\
  \minpr(\ty{\emptyenv})                     & = & \ptop
\end{array}
\]

\subsubsection*{Terms}
Terms ($\tm{L}$, $\tm{M}$, $\tm{N}$) are defined by the following grammar:
\[
\begin{array}{lcl}
  \tm{L}, \tm{M}, \tm{N}
  & \Coloneqq & \tm{x}
    \sep        \tm{K}
    \sep        \tm{\lambda x.M}
    \sep        \tm{M\;N} \\
  & \sep      & \tm{\unit}
    \sep        \tm{\letunit{M}{N}}
    \sep        \tm{\pair{M}{N}}
    \sep        \tm{\letpair{x}{y}{M}{N}} \\
  & \sep      & \tm{\inl{M}}
    \sep        \tm{\inr{M}}
    \sep        \tm{\casesum{L}{x}{M}{y}{N}}
    \sep        \tm{\absurd{M}} \\
  \tm{K}
  & \Coloneqq & \tm{\link}
    \sep        \tm{\new}
    \sep        \tm{\spawn}
    \sep        \tm{\send}
    \sep        \tm{\recv}
    \sep        \tm{\close}
    \sep        \tm{\wait}
\end{array}
\]
Let $\tm{x}$, $\tm{y}$, $\tm{z}$, and $\tm{w}$ range over variable names. Occasionally, we use $\tm{a}$, $\tm{b}$, $\tm{c}$, and $\tm{d}$. The term language is the standard linear $\lambda$-calculus with products, sums, and their units, extended with constants $\tm{K}$ for the communication primitives. 

The constants are best understood in conjunction with their typing and reduction rules in~\cref{fig:pgv-typing,fig:pgv-operational-semantics}. Briefly, $\tm{\link}$ links two endpoints together, forwarding messages from each to the other, $\tm{\new}$ creates a new channel and returns a pair of its endpoints, and $\tm{\spawn}$ spawns off its argument as a new thread. The $\tm{\send}$ and $\tm{\recv}$ functions send and receive values on a channel. However, since the typing rules for PGV ensure the linear usage of endpoints, they also return a new copy of the endpoint, to continue the session. The $\tm{\close}$ and $\tm{\wait}$ functions close a channel.

We use syntactic sugar to make terms more readable: we write $\tm{\andthen{M}{N}}$ in place of $\tm{\letunit{M}{N}}$, $\tm{\letbind{x}{M}{N}}$ in place of $\tm{(\lambda x.N)\;M}$, and pattern matching functions $\tm{\lambda\unit.M}$ in place of $\tm{\lambda z.\letunit{z}{M}}$ and $\tm{\lambda\pair{x}{y}.M}$ in place of $\tm{\lambda z.\letpair{x}{y}{z}{M}}$.
% We recover $\tm{\fork}$ as $\tm{\lambda x.\letpair{y}{z}{\new\;\unit}{\andthen{\spawn\;{(\lambda\unit.x\;y)}}{z}}}$.

\subsubsection*{Internal and External Choice}
Typically, session-typed languages feature constructs for internal and external choice. In GV, these can be defined in terms of the core language, by sending or receiving a value of a sum type~\cite{lindleymorris15}. We use the following syntactic sugar for internal ($\ty{\tyselect[\cs{o}]{S}{S'}}$) and external ($\ty{\tyoffer[\cs{o}]{S}{S'}}$) choice and their units:
\[
\begin{array}{lcl}
  \ty{\tyselect[\cs{o}]{S}{S'}}
  & \elabarrow & \ty{\tysend[\cs{o}]{(\tysum{\co{S}}{\co{S'}})}{\tyends[\cs{o+1}]}} \\
  \ty{\tyoffer[\cs{o}]{S}{S'}}
  & \elabarrow & \ty{\tyrecv[\cs{o}]{(\tysum{S}{S'})}{\tyendr[\cs{o+1}]}} \\
\end{array}
\qquad
\begin{array}{lcl}
  \ty{\tyselectemp[\cs{o}]}
  & \elabarrow & \ty{\tysend[\cs{o}]{\tyvoid}{\tyends[\cs{o+1}]}} \\
  \ty{\tyofferemp[\cs{o}]}
  & \elabarrow & \ty{\tyrecv[\cs{o}]{\tyvoid}{\tyendr[\cs{o+1}]}} \\
\end{array}
\]
As the syntax for units suggests, these are the binary and nullary forms of the more common n-ary choice constructs $\ty{{\oplus}^{\cs{o}}\{l_i:S_i\}_{i\in{I}}}$ and $\ty{{\with}^{\cs{o}}\{l_i:S_i\}_{i\in{I}}}$, which one may obtain generalising the sum types to variant types. For simplicity, we present only the binary and nullary forms.

Similarly, we use syntactic sugar for the term forms of choice, which combine sending and receiving with the introduction and elimination forms for the sum and empty types. There are two constructs for binary internal choice, expressed using the meta-variable $\tm{\ell}$ which ranges over $\{\tm{\labinl},\tm{\labinr}\}$. As there is no introduction for the empty type, there is no construct for nullary internal choice:
\[
\begin{array}{lcl}
  \tm{\select{\ell}}
  & \elabarrow & \tm{\lambda x.\letpair{y}{z}{\new}{\andthen{\close\;(\send\;{\pair{\ell\;y}{x}})}{z}}} \\
  \multicolumn{3}{l}{\tm{\offer{L}{x}{M}{y}{N}}\elabarrow} \\
  \multicolumn{3}{l}{
  \qquad\tm{\letpair{z}{w}{\recv\;{L}}{\andthen{\wait\;{w}}{\casesum{z}{x}{M}{y}{N}}}}} \\
  \tm{\offeremp{L}}
  & \elabarrow & \tm{\letpair{z}{w}{\recv\;L}{\andthen{\wait\;{w}}{\absurd{z}}}}
\end{array}
\]

\subsubsection*{Operational Semantics}
Priority GV terms are evaluated as part of a configuration of processes. Configurations are defined by the following grammar:
\[
\begin{array}[t]{lcl}
    \tm{\conf{C}}, \tm{\conf{D}}, \tm{\conf{E}}
  & \Coloneqq & \tm{\phi\;M}
    \sep        \tm{\ppar{\conf{C}}{\conf{D}}}
    \sep        \tm{\res{x}{x'}{\conf{C}}}
  \\
  \tm{\phi}
  & \Coloneqq & \tm{\main}
    \sep        \tm{\child}
\end{array}
\]
Configurations ($\tm{\conf{C}}$, $\tm{\conf{D}}$, $\tm{\conf{E}}$) consist of threads $\tm{\phi\;M}$, parallel compositions $\tm{\ppar{\conf{C}}{\conf{D}}}$, and name restrictions $\tm{\res{x}{x'}{\conf{C}}}$. To preserve the functional nature of PGV, where programs return a single value, we use flags ($\tm{\phi}$) to differentiate between the main thread, marked $\tm{\main}$, and child threads created by $\tm{\spawn}$, marked $\tm{\child}$. Only the main thread returns a value. We determine the flag of a configuration by combining the flags of all threads in that configuration:
\[
  \tm{\main}  + \tm{\child} = \tm{\main}
  \quad
  \tm{\child} + \tm{\main}  = \tm{\main}
  \quad
  \tm{\child} + \tm{\child} = \tm{\child}
  \quad
  (\tm{\main}  + \tm{\main} \; \text{is undefined})
\]
Values ($\tm{V}$, $\tm{W}$), evaluation contexts ($\tm{E}$), thread evaluation contexts ($\tm{\conf{F}}$), and configuration contexts ($\tm{\conf{G}}$) are defined by the following grammars:
\[
\begin{array}[t]{lcl}
  \tm{V}, \tm{W}
  & \Coloneqq & \tm{x}
    \sep        \tm{K}
    \sep        \tm{\lambda x.M}
    \sep        \tm{\unit}
    \sep        \tm{\pair{V}{W}}
    \sep        \tm{\inl{V}}
    \sep        \tm{\inr{V}}
  \\
  \tm{E}
  & \Coloneqq & \tm{\hole} \\
  & \sep      & \tm{E\;M}
    \sep        \tm{V\;E} \\
  & \sep      & \tm{\letunit{E}{N}} \\
  & \sep      & \tm{\pair{E}{M}}
    \sep        \tm{\pair{V}{E}}
    \sep        \tm{\letpair{x}{y}{E}{M}} \\
  & \sep      & \tm{\inl{E}}
    \sep        \tm{\inr{E}}
    \sep        \tm{\casesum{E}{x}{M}{y}{N}} \\
  & \sep      & \tm{\absurd{E}}
  \\
  \tm{\conf{F}}
  & \Coloneqq & \tm{\phi\;E}
  \\
  \tm{\conf{G}}
  & \Coloneqq & \tm{\hole}
    \sep        \tm{\ppar{\conf{G}}{\conf{C}}}
    \sep        \tm{\res{x}{y}{\conf{G}}}
\end{array}
\]
We factor the reduction relation of PGV into a deterministic reduction on terms ($\tred$) and a non-deterministic reduction on configurations ($\cred$), see \cref{fig:pgv-operational-semantics}. We write $\tred^+$ and $\cred^+$ for the transitive closures, and $\tred^\star$ and $\cred^\star$ for the reflexive-transitive closures.

Term reduction is the standard call-by-value, left-to-right evaluation for GV, and only deviates from reduction for the linear $\lambda$-calculus in that it reduces terms to values \emph{or} ready terms waiting to perform a communication action.

Configuration reduction resembles evaluation for a process calculus: \LabTirName{E-Link}, \LabTirName{E-Send}, and \LabTirName{E-Close} perform communications, \LabTirName{E-LiftC} allows reduction under configuration contexts, and \LabTirName{E-LiftSC} embeds a structural congruence $\equiv$. The remaining rules mediate between the process calculus and the functional language: \LabTirName{E-New} and \LabTirName{E-Spawn} evaluate the $\tm{\new}$ and $\tm{\spawn}$ constructs, creating the equivalent configuration constructs, and \LabTirName{E-LiftM} embeds term reduction.

Structural congruence satisfies the following axioms: $\LabTirName{SC-LinkSwap}$ allows swapping channels in the link process. $\LabTirName{SC-ResLink}$ allows restriction to applied to link which is structurally equivalent to the terminated process, thus allowing elimination of unnecessary restrictions. $\LabTirName{SC-ResSwap}$ allows swapping channels and $\LabTirName{SC-ResComm}$ states that restriction is commutative. $\LabTirName{SC-ResExt}$ is the standard scope extrusion rule. Rules $\LabTirName{SC-ParNil}$, $\LabTirName{SC-ParComm}$ and $\LabTirName{SC-ParAssoc}$ state that parallel composition uses the terminated proceess as the neutral element; it is commutative and associative.

While our configuration reduction is based on the standard evaluation for GV, the increased expressiveness of PGV allows us to simplify the relation on two counts.
Firstly, we decompose the $\tm{\fork}$ construct. In GV, $\tm{\fork}$ creates a new channel, spawns a child thread, and, when the child thread finishes, it closes the channel to its parent. In PGV, these are three separate operations: $\tm{\new}$, $\tm{\spawn}$, and $\tm{\close}$. We no longer require that every child thread finishes by returning a terminated channel. Consequently, we also simplify the evaluation of the $\tm{\link}$ construct. In GV, $\tm{\link}$ needs to return a terminated channel after evaluating the link. In PGV, the behaviour matches that of link in CP.
Secondly, our structural congruence is type preserving. Consequently, we can embed it directly into the reduction relation. In GV, this is not the case, and subject reduction relies on proving that if $\equiv\cred$ ends up in an ill-typed configuration, we can rewrite it to a well-typed configuration using $\equiv$.

\input{fig/pgv-operational-semantics}

\subsubsection*{Typing}
Terms are typed by a judgement $\tseq[\cs{p}]{\ty{\Gamma}}{M}{T}$, which states that ``a term $\tm{M}$ has type $\ty{T}$ and an upper bound on its priority $\cs{p}$ under the typing environment $\ty{\Gamma}$''. Typing is standard for the linear $\lambda$-calculus. Linearity is ensured by splitting environments on branching rules, requiring that the environment in the variable rule consists of just the variable, and the environment in the constant and unit rules are empty. The constants $\tm{K}$ are typed using type schemas, and embedded using \LabTirName{T-Const}. \Cref{fig:pgv-typing} gives the typing rules for PGV.

The only non-standard feature of the typing rules is the priority annotations. Priorities are based on \emph{obligations/capabilities} used by Kobayashi~\cite{kobayashi06}, and simplified to single priorities following Padovani~\cite{padovani14}. The integration of priorities into GV is adapted from Padovani and Novara~\cite{padovaninovara15}. Paraphrasing Dardha and Gay~\cite{dardhagay18}, priorities obey the following two laws:
\begin{enumerate}
  \item an action with priority $\cs{o}$ happens before an action with priority $\cs{o+n}$;
  \item communication requires \emph{equal} priorities for the dual actions.
\end{enumerate}

In PGV\simon{I think the rules need more explanation than this---as someone who knows the basics of priorities but is not an expert, I found it difficult to understand the T-Lam rule for example}, sequents are annotated by a priority bound $\cs{p}$, which is the \emph{upper bound} on the priority of the communication actions performed while evaluating the term. The \emph{lower bound} is obtained from the typing environment. Terms with sequential evaluation, such as \LabTirName{T-LetUnit}, have side conditions to ensure deadlock freedom. For instance, the side condition for typing $\tm{\letunit{M}{N}}$ requires that $\tm{M}$ has finished communicating before $\tm{N}$ starts communicating.

Configurations are typed by a judgement $\cseq[\phi]{\ty{\Gamma}}{\conf{C}}$, which states that ``a configuration $\tm{\conf{C}}$ with flag $\phi$ is well-typed under typing environment $\ty{\Gamma}$''. Configuration typing is based on the standard typing for GV. Terms are embedded either as main or as child threads. The priority bound from the term typing is discarded, as configurations contain no further blocking actions. Main threads are allowed to return a value, whereas child threads are required to return the unit value. Sequents are annotated with a flag $\phi$, which ensure that there is at most one main thread.

While our configuration typing is based on the standard typing for GV, it differs on two counts.
Firstly, we require that child threads return the unit value, as opposed to a terminated channel.
Secondly, we simplify typing for parallel composition. In GV, each parallel composition must split \emph{exactly one} channel of the channel pseudo-type $\ty{S^\sharp}$ into two endpoints of type $\ty{S}$ and $\ty{\co{S}}$ across the parallel composition. Consequently, associativity of parallel composition does not preserve typing. Unfortunately, splitting exactly one channel across a parallel composition in GV plays a crucial role in guaranteeing deadlock freedom. In PGV, we guarantee deadlock freedom using priorities, which removes the channel pseudo-type $\ty{S^\sharp}$, simplifies typing for parallel composition, and restores type preservation for the structural congruence.

\input{fig/pgv-typing}


\subsubsection*{Subject reduction}
Unlike with previous versions of GV, structural congruence, term reduction, and configuration reduction are all type preserving.

We must show that substitution preserves priority constraints. For this, we prove~\cref{lem:pgv-value-done}, which shows that values have finished all their communication, and that any priorities in the type of the value come from the typing environment.
\begin{compacttheorems}
  \begin{restatablelemma}{lempgvvaluedone}
    \label{lem:pgv-value-done}
    If $\tseq[\cs{p}]{\ty{\Gamma}}{V}{T}$, then $\cs{p}=\cs{\pbot}$, and $\minpr(\ty{\Gamma})=\minpr(\ty{T})$.
  \end{restatablelemma}
  \begin{proof}
    By induction on the derivation of $\tseq[\cs{p}]{\ty{\Gamma}}{V}{T}$. We demonstrate the case for \LabTirName{T-Inl}, as it illustrates the need for the side conditions on \LabTirName{T-Inl} and \LabTirName{T-Inr}:
    \begin{case*}[\LabTirName{T-Inl}]
      The induction hypothesis gives us $\cs{p}=\cs{\pbot}$, and $\pr(\ty{\Gamma})=\pr{(\ty{T})}$. We know $\pr(\ty{T})=\pr({\ty{U}})$, hence $\pr(\ty{\Gamma})=\pr(\ty{\tysum{T}{U}})$.
      \begin{mathpar}
        \small
        \inferrule*{
          \tseq[\cs{p}]{\ty{\Gamma}}{V}{T}
          \\
          \pr(\ty{T})=\pr(\ty{U})
        }{\tseq[\cs{p}]{\ty{\Gamma}}{\inl{V}}{\tysum{T}{U}}}
      \end{mathpar}
    \end{case*}
    The full proof can be found in~\cref{prf:lem-pgv-value-done}.
  \end{proof}
  \begin{restatablelemma}{lempgvsubstitution}[Substitution]
    \label{lem:pgv-substitution}
    \hfill\\%newline before theorem statement
    If $\tseq[\cs{p}]{\ty{\Gamma},\tmty{x}{U'}}{M}{T}$ and $\tseq[\cs{q}]{\ty{\Theta}}{V}{U'}$, then $\tseq[\cs{p}]{\ty{\Gamma},\ty{\Theta}}{\subst{M}{V}{x}}{T}$.
  \end{restatablelemma}
  \begin{proof}
    By induction on the derivation of $\tseq[\cs{p}]{\ty{\Gamma},\tmty{x}{U'}}{M}{T}$. Whenever the contexts in the premises and conclusion differ, we use \cref{lem:pgv-value-done} to prove that the priorities are preserved. We demonstrate the case for \LabTirName{T-Lam}:
    \begin{case*}[\LabTirName{T-Lam}]
      By \cref{lem:pgv-value-done}, $\pr(\ty{\Theta})=\pr(\ty{U'})$, hence $\pr(\ty{\Gamma},\ty{\Theta})=\pr(\ty{\Gamma},\ty{U'})$.
      \begin{mathpar}
        \small
        \inferrule*{
          \tseq[\cs{q}]{\ty{\Gamma},\tmty{x}{U'},\tmty{y}{T}}{M}{U}
        }{\tseq[\cs{\pbot}]{\ty{\Gamma},\tmty{x}{U'}}
          {\lambda y.M}
          {\tylolli[\cs{\pr(\ty{\Gamma},\ty{U'})},\cs{q}]{T}{U}}}
        \substarrow{V}{x}
        \inferrule*{
          \tseq[\cs{q}]{\ty{\Gamma},\ty{\Theta},\tmty{y}{T}}{\subst{M}{V}{x}}{U}
        }{\tseq[\cs{\pbot}]{\ty{\Gamma},\ty{\Theta}}
          {\lambda y.\subst{M}{V}{x}}
          {\tylolli[\cs{\pr(\ty{\Gamma},\ty{\Theta})},\cs{q}]{T}{U}}}
      \end{mathpar}
    \end{case*}
    The complete proof can be found in~\cref{prf:lem-pgv-substitution}.
  \end{proof}
\end{compacttheorems}
The proofs for subject congruence and subject reduction are standard inductions. The details can be found in \cref{prf:lem-pgv-subject-reduction-terms,prf:lem-pgv-subject-congruence,prf:thm-pgv-subject-reduction-confs}.
\begin{compacttheorems}
  \begin{restatablelemma}{lempgvsubjectreductionterms}[Subject Reduction, $\tred$]
    \label{lem:pgv-subject-reduction-terms}
    \hfill\\%newline before theorem statement
    If $\tseq[\cs{p}]{\ty{\Gamma}}{M}{T}$ and $\tm{M}\tred\tm{M'}$,
    then $\tseq[\cs{p}]{\ty{\Gamma}}{M'}{T}$.
  \end{restatablelemma}
  \begin{restatablelemma}{lempgvsubjectcongruence}[Subject Congruence, $\equiv$]
    \label{lem:pgv-subject-congruence}
    \hfill\\%newline before theorem statement
    If $\cseq[\phi]{\ty{\Gamma}}{\conf{C}}$ and $\tm{\conf{C}}\equiv\tm{\conf{C'}}$,
    then $\cseq[\phi]{\ty{\Gamma}}{\conf{C'}}$.
  \end{restatablelemma}
  \begin{restatabletheorem}{thmpgvsubjectreductionconfs}[Subject Reduction, $\cred$]
    \label{thm:pgv-subject-reduction-confs}
    \hfill\\%newline before theorem statement
    If $\cseq[\phi]{\ty{\Gamma}}{\conf{C}}$ and $\tm{\conf{C}}\cred\tm{\conf{C'}}$,
    then $\cseq[\phi]{\ty{\Gamma}}{\conf{C'}}$.
  \end{restatabletheorem}
\end{compacttheorems}

\subsubsection*{Progress and deadlock freedom}
PGV satisfies progress, as PGV configurations either reduce or are in normal form. However, the normal forms may seem surprising at first, as evaluating a well-typed PGV term does not necessarily produce \emph{just} a value. If a term returns an endpoint, then its normal form contains a thread which is ready to communicate on the dual of that endpoint. This behaviour is not new to PGV. Let us consider an example, adapted from Lindley and Morris~\cite{lindleymorris15}, in which a term returns an endpoint linked to an echo server. The echo server receives a value and sends it back unchanged:
\[
  \tm{\echo_x} \defeq \tm{\letpair{y}{x}{\recv\;{x}}{\letbind{x}{\send\;\pair{y}{x}}{\close\;x}}}
\]
Consider the program which creates a new channel, with endpoints $\tm{x}$ and $\tm{x'}$, spawns off an echo server listening on $\tm{x'}$, and then returns $\tm{x}$:
\[
  \tm{\main\;\letpair{x}{x'}{\new}{\andthen{\spawn\;(\lambda\unit.\echo_{x'})}}{x}}
\]
If we reduce the above program, we get $\tm{\res{x}{x'}{(\ppar{\main\;x}{\child\;\echo_{x'}})}}$. Clearly, no more evaluation is possible, even though the configuration contains the thread $\tm{\child\;\echo_{x'}}$, which is blocked on $\tm{x'}$. In~\cref{cor:pgv-closed-progress} we show that if a term does not return an endpoint, it must produce \emph{only} a value.

\emph{Actions} are terms which perform communication actions which synchronisation between two threads:
\begin{definition}[Actions]
  \label{def:pgv-actions}
  A~term \emph{acts on} an endpoint $\tm{x}$ if it is of the form $\tm{\send\;\pair{V}{x}}$, $\tm{\recv\;{x}}$, $\tm{\close\;{x}}$, or $\tm{\wait\;{x}}$. A~term is an \emph{action} if it acts on some endpoint $\tm{x}$.
\end{definition}

\emph{Ready terms} are terms which are ready to perform a communication action, either by themselves, \eg creating a new channel or thread, or with another thread, \eg sending or receiving:
\begin{definition}[Ready Terms]
  \label{def:pgv-ready-actions}
  A~term $\tm{L}$ is \emph{ready} if it is of the form $\tm{\plug{E}{M}}$, where $\tm{M}$ is of the form $\tm{\new}$, $\tm{\spawn\;N}$, $\tm{\link\;\pair{x}{y}}$ or $\tm{\link\;\pair{y}{x}}$, or $\tm{M}$ acts on $\tm{x}$. In the latter case, we say that $\tm{L}$ is \emph{ready to act on} $\tm{x}$.
\end{definition}

Progress for the term language is standard for GV, and deviates from progress for linear $\lambda$-calculus only in that terms may reduce to values or \emph{ready terms}:
\begin{restatablelemma}{lempgvopenprogressterms}[Progress, $\tred$]
  \label{lem:pgv-open-progress-terms}
  If $\tseq[\cs{p}]{\ty{\Gamma}}{M}{T}$ and $\ty{\Gamma}$ contains only session types, then:
  \begin{itemize}
  \item $\tm{M}$ is a value;
  \item $\tm{M}\tred\tm{N}$ for some term $\tm{N}$; or
  \item $\tm{M}$ is ready.
  \end{itemize}
\end{restatablelemma}

Canonical forms deviate from those for GV, in that we opt to move all $\nu$-binders to the top. The standard GV canonical form, alternating $\nu$-binders and their corresponding parallel compositions, does not work for PGV, since multiple channels may be split across a single parallel composition.

A~configuration either reduces, or it is equivalent to configuration in normal form. Crucial to the normal form is that each term $\tm{M_i}$ is blocked on the corresponding channel $\tm{x_i}$, and hence no two terms act on dual endpoints. Furthermore, no term $\tm{M_i}$ can perform a communication action by itself, since those are excluded by the definition of actions.
Finally, as a corollary, we get that well-typed terms which do not return endpoints return \emph{just} a value:

\begin{compacttheorems}
  \begin{definition}[Canonical Forms]
    \label{def:pgv-canonical-forms}
    A~configuration $\tm{\conf{C}}$ is in canonical form if it is of the following form, where no term $\tm{M_i}$ is a value:
    \[
      \tm{\res{x_1}{x'_1}{\dots\res{x_n}{x'_n}{(\child\;M_1\parallel\dots\parallel\child\;M_m\parallel\main\;N)}}}
    \]
  \end{definition}
  \begin{definition}[Normal Forms]
    A~configuration $\tm{\conf{C}}$ is in normal form if it is of the following form, where each $\tm{M_i}$ is ready to act on $\tm{x_i}$:
    \[
      \tm{\conf{C}}
      \equiv
      \tm{\res{x_1}{x'_1}{\dots\res{x_n}{x'_n}{(\child\;M_1\parallel\dots\parallel\child\;M_m\parallel\main\;V)}}},
    \]
  \end{definition}
  \begin{restatabletheorem}{thmpgvclosedprogressconfs}[Progress, $\cred$]
    \label{thm:pgv-closed-progress-confs}
    If $\cseq[\main]{\emptyenv}{\conf{C}}$ and $\tm{\conf{C}}$ is in canonical form, then either $\tm{\conf{C}}\cred\tm{\conf{D}}$ for some $\tm{\conf{D}}$; or $\tm{\conf{C}\equiv\conf{D}}$ for some $\tm{\conf{D}}$ in normal form.
  \end{restatabletheorem}
  \begin{proof}
    Our proof follows the reasoning by Kobayashi~\cite{kobayashi06} used in the proof of deadlock freedom for closed processes (Theorem 2). Details are in~\Cref{prf:thm-pgv-closed-progress-confs}.
  \end{proof}
  \begin{corollary}
    \label{cor:pgv-closed-progress}
    If $\cseq[\main]{\emptyenv}{\conf{C}}$, $\tm{\conf{C}}\centernot\cred$, and $\tm{\conf{C}}$ contains no endpoints, then $\tm{\conf{C}}\equiv\tm{\phi\;V}$ for some value V.
  \end{corollary}
\end{compacttheorems}

\end{document}

%%% Local Variables:
%%% TeX-master: "priorities"
%%% End:
