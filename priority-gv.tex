\documentclass[main.tex]{subfiles}

\begin{document}

\section{Priority GV}
\usingnamespace{pgv}

\subsection{Syntax}

\paragraph*{Priorities, types, and environments}
Types are divided into \emph{session types} $\ty{S}$ and \emph{value types} $\ty{T}$, $\ty{U}$.

Session types are annotated with \emph{priorities} $\cs{o}\in\mathbb{N}$.
The types $\ty{\tysend[\cs{o}]{T}{S}}$ and $\ty{\tyrecv[\cs{o}]{T}{S}}$ type the endpoints of a channel over which we send or receive a value of type $\ty{T}$, and then proceed as $\ty{S}$.
The types $\ty{\tyends[\cs{o}]}$ and $\ty{\tyendr[\cs{o}]}$ type endpoints of a channel whose session has finished, and over which we send or receive a ping before closing the channel.
\[
\begin{array}{lcl}
  \ty{S}
  & \coloneqq & \ty{\tysend[\cs{o}]{T}{S}}
    \sep        \ty{\tyrecv[\cs{o}]{T}{S}}
    \sep        \ty{\tyends[\cs{o}]}
    \sep        \ty{\tyendr[\cs{o}]}
\end{array}
\]
Value types are based on the types of the linear $\lambda$-calculus.
The types $\ty{\typrod{T}{U}}$, $\ty{\tyunit}$, $\ty{\tysum{T}{U}}$, and $\ty{\tyvoid}$ are the standard linear $\lambda$-calculus product type, unit type, sum type, and empty type.
The type $\ty{\tylolli[\cs{p},\cs{q}]{T}{U}}$ is the standard linear function type, annotated with \emph{priority bounds} $\cs{p},\cs{q}\in\mathbb{N}\cup\{\cs{\pbot},\cs{\ptop}\}$.
Session types are value types, as endpoints are values.
\[
\begin{array}{lcl}
  \ty{T}, \ty{U}
  & \coloneqq & \ty{\typrod{T}{U}}
    \sep        \ty{\tyunit}
    \sep        \ty{\tysum{T}{U}}
    \sep        \ty{\tyvoid}
    \sep        \ty{\tylolli[\cs{p},\cs{q}]{T}{U}}
    \sep        \ty{S}
\end{array}
\]
Given a function with type $\ty{\tylolli[\cs{p},\cs{q}]{T}{U}}$, the priority bound $\cs{p}$ is a \emph{lower bound} on the priorities of the channel names captured by the body of the function, and the priority bound $\cs{q}$ is an \emph{upper bound} on the priority of the communications that take place as a result of applying the function.
We discuss this in more detail when we give the typing rules.
We define syntactic sugar for the type of \emph{pure functions}.
\[
  \ty{\tylolli{T}{U}} \elabarrow \ty{\tylolli[\cs{\ptop},\cs{\pbot}]{T}{U}}
\]
A typing context $\ty\Gamma$ is a partial function associating names to types.
\[
\begin{array}{lcl}
  \ty{\Gamma}, \ty{\Delta}
  & \coloneqq & \ty{\emptyenv}
    \sep        \ty{\Gamma}, \tmty{x}{T}
\end{array}
\]
\[
\begin{array}{lcl}
  \ty{\co{\tysend[\cs{o}]{T}{S}}} & = & \ty{\tyrecv[\cs{o}]{T}{\co{S}}} \\
  \ty{\co{\tyrecv[\cs{o}]{T}{S}}} & = & \ty{\tysend[\cs{o}]{T}{\co{S}}}
\end{array}
\qquad
\begin{array}{lcl}
  \ty{\co{\tyends[\cs{o}]}} & = & \ty{\co{\tyendr[\cs{o}]}} \\
  \ty{\co{\tyendr[\cs{o}]}} & = & \ty{\co{\tyends[\cs{o}]}}
\end{array}
\]
\[
\begin{array}{lcl}
  \pr(\ty{\tysend[\cs{o}]{T}{S}})            & = & \cs{o} \\
  \pr(\ty{\tyrecv[\cs{o}]{T}{S}})            & = & \cs{o} \\
\end{array}
\qquad
\begin{array}{lcl}
  \pr(\ty{\tyends[\cs{o}]})                  & = & \cs{o} \\
  \pr(\ty{\tyendr[\cs{o}]})                  & = & \cs{o} \\
\end{array}
\]
\[
\begin{array}{lcl}
  \minpr(\ty{\typrod{T}{U}})                 & = & \minpr({\ty{T}})\sqcap\minpr({\ty{U}}) \\
  \minpr(\ty{\tysum{T}{U}})                  & = & \minpr({\ty{T}})\sqcap\minpr({\ty{U}}) \\
  \minpr(\ty{\tylolli[\cs{p},\cs{q}]{T}{U}}) & = & \cs{p} \\
  \\
  \minpr(\ty{\Gamma}, \tmty{x}{A})           & = & \minpr(\ty{\Gamma})\sqcap\pr(\ty{A})
\end{array}
\qquad
\begin{array}{lcl}
  \minpr(\ty{\tyunit})                       & = & \ptop \\
  \minpr(\ty{\tyvoid})                       & = & \ptop \\
  \minpr(\ty{S})                             & = & \pr(\ty{S}) \\
  \\
  \minpr(\ty{\emptyenv})                     & = & \ptop
\end{array}
\]

\paragraph*{Static Term Syntax}
We use $\tm{x}$, $\tm{y}$, $\tm{z}$, and $\tm{w}$ to range over variable names. Occasionally, we use $\tm{a}$, $\tm{b}$, and $\tm{c}$ to range over \emph{free} channel endpoints.
\[
\begin{array}{lcl}
  \tm{L}, \tm{M}, \tm{N}
  & \coloneqq & \tm{x}
    \sep        \tm{K}
    \sep        \tm{\lambda x.M}
    \sep        \tm{M\;N} \\
  & \sep      & \tm{\unit}
    \sep        \tm{\letunit{M}{N}} \\
  & \sep      & \tm{\pair{M}{N}}
    \sep        \tm{\letpair{x}{y}{M}{N}} \\
  & \sep      & \tm{\inl{M}}
    \sep        \tm{\inr{M}}
    \sep        \tm{\casesum{L}{x}{M}{y}{N}} \\
  & \sep      & \tm{\absurd{M}} \\
  \tm{K}
  & \coloneqq & \tm{\link}
    \sep        \tm{\new}
    \sep        \tm{\spawn}
    \sep        \tm{\send}
    \sep        \tm{\recv}
    \sep        \tm{\wait}
    \sep        \tm{\close}
\end{array}
\]

\paragraph*{Syntactic Sugar for Terms}
\[
\begin{array}{lcl}
  \tm{\andthen{M}{N}}
  & \elabarrow & \tm{\letunit{M}{N}} \\
  \tm{\letbind{x}{M}{N}}
  & \elabarrow & \tm{(\lambda x.N)\;M} \\
  \tm{\lambda\unit.M}
  & \elabarrow & \tm{\lambda z.\letunit{z}{M}} \\
  \tm{\lambda\pair{x}{y}.M}
  & \elabarrow & \tm{\lambda z.\letpair{x}{y}{z}{M}} \\
  \tm{\fork}
  & \elabarrow & \tm{\lambda x.\letpair{y}{z}{\new}{\andthen{\spawn\;{(\lambda\unit.x\;y)}}{z}}}
\end{array}
\]

\paragraph*{Syntactic Sugar for Internal and External Choice}
\[
\begin{array}{lcl}
  \ty{\tyselect[\cs{o}]{S}{S'}}
  & \elabarrow & \ty{\tysend[\cs{o}]{(\tysum{\co{S}}{\co{S'}})}{\tyends[\cs{o+1}]}} \\
  \ty{\tyoffer[\cs{o}]{S}{S'}}
  & \elabarrow & \ty{\tyrecv[\cs{o}]{(\tysum{S}{S'})}{\tyendr[\cs{o+1}]}} \\
\end{array}
\qquad
\begin{array}{lcl}
  \ty{\tyselectemp[\cs{o}]}
  & \elabarrow & \ty{\tysend[\cs{o}]{\tyvoid}{\tyends[\cs{o+1}]}} \\
  \ty{\tyofferemp[\cs{o}]}
  & \elabarrow & \ty{\tyrecv[\cs{o}]{\tyvoid}{\tyendr[\cs{o+1}]}} \\
\end{array}
\]
\[
\begin{array}{lcl}
  \tm{\select{\ell}}
  & \elabarrow & \tm{\lambda x.\letpair{y}{z}{\new}{\andthen{\close\;(\send\;{\pair{\ell\;y}{x}})}{z}}} \\
  \multicolumn{3}{l}{\tm{\offer{L}{x}{M}{y}{N}}\elabarrow} \\
  \multicolumn{3}{l}{
  \qquad\tm{\letpair{z}{w}{\recv\;{L}}{\andthen{\wait\;{w}}{\casesum{z}{x}{M}{y}{N}}}}} \\
  \tm{\offeremp{L}}
  & \elabarrow & \tm{\letpair{z}{w}{\recv\;L}{\andthen{\wait\;{w}}{\absurd{z}}}}
\end{array}
\]

\paragraph*{Runtime Term Syntax}
\[
\begin{array}[t]{lcl}
  \tm{\conf{C}}, \tm{\conf{D}}, \tm{\conf{E}}
  & \coloneqq & \tm{\phi\;M}
    \sep        \tm{\ppar{\conf{C}}{\conf{D}}}
    \sep        \tm{\res{x}{y}{\conf{C}}}
  \\
  \tm{\phi}
  & \coloneqq & \tm{\main}
    \sep        \tm{\child}
  \\
  \tm{V}, \tm{W}
  & \coloneqq & \tm{x}
    \sep        \tm{K}
    \sep        \tm{\lambda x.M}
    \sep        \tm{\unit}
    \sep        \tm{\pair{M}{N}}
    \sep        \tm{\inl{M}}
    \sep        \tm{\inr{M}}
  \\
  \tm{E}
  & \coloneqq & \tm{\hole} \\
  & \sep      & \tm{E\;M}
    \sep        \tm{V\;E} \\
  & \sep      & \tm{\letunit{E}{N}} \\
  & \sep      & \tm{\pair{E}{M}}
    \sep        \tm{\pair{V}{E}}
    \sep        \tm{\letpair{x}{y}{E}{M}} \\
  & \sep      & \tm{\inl{E}}
    \sep        \tm{\inr{E}}
    \sep        \tm{\casesum{E}{x}{M}{y}{N}} \\
  & \sep      & \tm{\absurd{E}} \\
  \\
  \tm{\conf{F}}
  & \coloneqq & \tm{\phi\;E}
  \\
  \tm{\conf{G}}
  & \coloneqq & \tm{\hole} \\
  & \sep      & \tm{\ppar{\conf{G}}{\conf{C}}}
    \sep        \tm{\res{x}{y}{\conf{G}}}
\end{array}
\]
\[
\begin{array}{ll}
  \tm{\main}  + \tm{\child} = \tm{\main}
  \\
  \tm{\child} + \tm{\main}  = \tm{\main}
\end{array}
\quad
\begin{array}{ll}
  \tm{\child} + \tm{\child} = \tm{\child}
  \\
  \tm{\main}  + \tm{\main} \; \text{undefined}
\end{array}
\]

\subsection{Typing}
See \cref{fig:pgv-typing}.
\input{fig/pgv-typing}

\todo{Define the ``priority bound of a term $\tm{M}$'' as $\cs{p}$ where $\tseq[\cs{p}]{\ty{\Gamma}}{M}{T}$.}

\subsection{Operational Semantics}
See \cref{fig:pgv-operational-semantics}.
\input{fig/pgv-operational-semantics}

\subsection{Metatheory}

\begin{restatablelemma}{lempgvvaluedone}
  \label{lem:pgv-value-done}
  If $\tseq[\cs{p}]{\ty{\Gamma}}{V}{T}$, then $\cs{p}=\cs{\pbot}$, and $\minpr(\ty{\Gamma})=\minpr(\ty{T})$.
\end{restatablelemma}
\begin{proof}
  By induction on the derivation of $\tseq[\cs{p}]{\ty{\Gamma}}{V}{T}$.
  (Details in \cref{prf:lem-pgv-value-done}.)
\end{proof}

\begin{restatablelemma}{lempgvsubstitution}[Substitution]
  \label{lem:pgv-substitution}
  \hfill\\%newline before theorem statement
  If $\tseq[\cs{p}]{\ty{\Gamma},\tmty{x}{U'}}{M}{T}$ and $\tseq[\cs{q}]{\ty{\Theta}}{V}{U'}$, then $\tseq[\cs{p}]{\ty{\Gamma},\ty{\Theta}}{\subst{M}{V}{x}}{T}$.
\end{restatablelemma}
\begin{proof}
  By induction on the derivation of $\tseq[\cs{p}]{\ty{\Gamma},\tmty{x}{U'}}{M}{T}$. Whenever the contexts in the premises and conclusion differ, we use \cref{lem:pgv-value-done} to prove that the priorities are preserved.
  (Details in \cref{prf:lem-pgv-substitution}.)
\end{proof}

\begin{restatablelemma}{lempgvsubjectreductionterms}[Subject Reduction, $\tred$]
  \label{lem:pgv-subject-reduction-terms}
  \hfill\\%newline before theorem statement
  If $\tseq[\cs{p}]{\ty{\Gamma}}{M}{T}$ and $\tm{M}\tred\tm{M'}$,
  then $\tseq[\cs{p}]{\ty{\Gamma}}{M'}{T}$.
\end{restatablelemma}
\begin{proof}
  By induction on the derivation of $\tm{M}\tred\tm{M'}$.
  (Details in \cref{prf:lem-pgv-subject-reduction-terms}.)
\end{proof}

\begin{restatablelemma}{lempgvsubjectcongruence}[Subject Congruence, $\equiv$]
  \label{lem:pgv-subject-congruence}
  \hfill\\%newline before theorem statement
  If $\cseq[\phi]{\ty{\Gamma}}{\conf{C}}$ and $\tm{\conf{C}}\equiv\tm{\conf{C'}}$,
  then $\cseq[\phi]{\ty{\Gamma}}{\conf{C'}}$.
\end{restatablelemma}
\begin{proof}
  By induction on the derivation of $\tm{\conf{C}}\equiv\tm{\conf{C'}}$.
  (Details in \cref{prf:lem-pgv-subject-congruence}.)
\end{proof}

\begin{restatabletheorem}{thmpgvsubjectreductionconfs}[Subject Reduction, $\cred$]
  \label{thm:pgv-subject-reduction-confs}
  \hfill\\%newline before theorem statement
  If $\cseq[\phi]{\ty{\Gamma}}{\conf{C}}$ and $\tm{\conf{C}}\cred\tm{\conf{C'}}$,
  then $\cseq[\phi]{\ty{\Gamma}}{\conf{C'}}$.
\end{restatabletheorem}
\begin{proof}
  By induction on the derivation of $\tm{\conf{C}}\cred\tm{\conf{C'}}$.
  (Details in \cref{prf:thm-pgv-subject-reduction-confs}.)
\end{proof}

\begin{definition}[Actions]
  \label{def:pgv-actions}
  A~term acts on an endpoint $\tm{x}$ if it is of the form $\tm{\send\;\pair{V}{x}}$, $\tm{\recv\;{x}}$, $\tm{\close\;{x}}$, or $\tm{\wait\;{x}}$. A~term is an action if it acts on some endpoint $\tm{x}$.
\end{definition}

\begin{definition}[Ready Terms]
  \label{def:pgv-ready-actions}
  A~term $\tm{L}$ is ready if it is of the form $\tm{\plug{E}{M}}$, where $\tm{M}$ is of the form $\tm{\new}$, $\tm{\spawn\;N}$, $\tm{\link\;\pair{x}{y}}$ or $\tm{\link\;\pair{y}{x}}$, or $\tm{M}$ acts on $\tm{x}$. In the last case, we say that $\tm{L}$ is ready to act on $\tm{x}$.
\end{definition}

\begin{restatablelemma}{lempgvreadypriority}
  \label{lem:pgv-ready-priority}
  If $\tseq[\cs{p}]{\ty{\Gamma}}{L}{T}$ is ready to act on $\tmty{x}{S}\in\ty{\Gamma}$, then the priority bound $\cs{p}$ is some priority $\cs{o}$, \ie not $\cs{\pbot}$ or $\cs{\ptop}$.
\end{restatablelemma}
\begin{proof}
  Let $\tm{L}=\tm{\plug{E}{M}}$. By induction on the structure of $\tm{E}$. $\tm{M}$ has priority $\pr({\ty{S}})$, and each constructor of the evaluation context $\tm{E}$ passes on the \emph{maximum} of the priorities of its premises. No rule introduces the priority bound $\cs{\ptop}$ on the sequent.
\end{proof}

\begin{restatablelemma}{lempgvopenprogressterms}[Open Progress, $\tred$]
  \label{lem:pgv-open-progress-terms}
  If $\tseq[\cs{p}]{\ty{\Gamma}}{M}{T}$, then:
  \begin{itemize}
  \item $\tm{M}$ is a value;
  \item $\tm{M}\tred\tm{N}$ for some term $\tm{N}$; or
  \item $\tm{M}$ is ready.
  \end{itemize}
\end{restatablelemma}
\begin{proof}
  \admit
\end{proof}

\begin{definition}[Canonical Forms]
  \label{def:pgv-canonical-forms}
  A~configuration $\tm{\conf{C}}$ is in canonical form if it is of the following form, where no term $\tm{M_i}$ is a value:
  \[
    \tm{\res{x_1}{x'_1}{\dots\res{x_n}{x'_n}{(\child\;M_1\parallel\dots\parallel\child\;M_m\parallel\main\;N)}}}
  \]
\end{definition}

\begin{restatablelemma}{lempgvcanonicalforms}[Canonical Forms]
  \label{lem:pgv-canonical-forms}
  If $\cseq[\main]{\ty{\Gamma}}{\conf{C}}$, there exists some $\tm{\conf{D}}$ such that $\tm{\conf{C}}\equiv\tm{\conf{D}}$ and $\tm{\conf{D}}$ is in canonical form.
\end{restatablelemma}
\begin{proof}
  We move any $\nu$-binders to the top using \LabTirName{SC-ResExt}, discard any superfluous occurrences of $\tm{\child\;\unit}$ using \LabTirName{SC-ParNil}, and move the main thread to the rightmost position using \LabTirName{SC-ParComm} and \LabTirName{SC-ParAssoc}.
\end{proof}

\begin{restatabletheorem}{thmpgvclosedprogressconfs}[Closed Progress, $\cred$]
  \label{lem:pgv-closed-progress-confs}
  If $\cseq[\main]{\emptyenv}{\conf{C}}$ and $\tm{\conf{C}}$ is in canonical form, then either $\tm{\conf{C}}\cred\tm{\conf{D}}$ for some $\tm{\conf{D}}$; or
  \[
    \tm{\conf{C}}
    =
    \tm{\res{x_1}{x'_1}{\dots\res{x_n}{x'_n}{(\child\;M_1\parallel\dots\parallel\child\;M_m\parallel\main\;V)}}},
  \]
  where each $\tm{M_i}$ is ready to act on $\tm{x_i}$.
\end{restatabletheorem}
\begin{proof}
  Details in \cref{prf:thm-pgv-closed-progress-confs}.
\end{proof}

\end{document}

%%% Local Variables:
%%% TeX-master: "priorities"
%%% End:
