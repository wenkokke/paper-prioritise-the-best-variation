% !TeX root = priorities.tex
\documentclass[main.tex]{subfiles}

\begin{document}
\section{Related Work and Conclusion}
\subsubsection*{Deadlock freedom and progress}
Deadlock freedom and progress are well studied properties in the $\pi$-calculus.
For the `standard' typed $\pi$-calculus, one line of work is Kobayashi's approach to deadlock freedom~\cite{kobayashi98}, where priorities are abstract tags defined over a partially ordered set. These tags were later simplified to pairs of natural numbers, called obligations and capabilities~\cite{kobayashi06}, which allowed more $\pi$-calculus processes to be typed. Padovani~\cite{padovani13} adapted the obligation and capability pairs to session types, and later simplified them to a single priority for the linear $\pi$-calculus~\cite{padovani14}.  Furthermore, by exploiting the encoding of session types into linear types~\cite{kobayashi07,dardhagiachino12,dardha14beat} and the priority-based linear $\pi$-calculus,
we can obtain deadlock freedom for the $\pi$-calculus with session types.

For the session-typed $\pi$-calculus, Dezani~\etal~\cite{dezani-ciancaglinimostrous06} guarantee progress by allowing only one active session at a time. Dezani later~\cite{dezani-ciancagliniliguoro09progress} introduces a partial order on channels similar to Kobayashi~\cite{kobayashi98}. Carbone and Debois~\cite{carbonedebois10} define progress for session typed $\pi$-calculus in terms of a \emph{catalyser}, which provides a missing counterpart to a process, thus guaranteeing deadlock freedom.
Carbone~\etal~\cite{carbonedardha14} use such catalysers to show that progress is a compositional form of lock-freedom and that it can be lifted to session types via the encoding of session types to linear types. Vieira and Vasconcelos~\cite{vieiravasconcelos13} use single priorities and an abstract partial order to guarantee deadlock freedom in a binary session-typed $\pi$-calculus and building on conservation types.

While our work focuses on \emph{binary} session types, it is worth to discuss related work on Multiparty Session Types (MPST) in order to give a broader context. The original work on MPST by Honda~\etal~\cite{hondayoshida08} guarantees deadlock freedom \emph{within a single} session, but not for session interleaving.
Later on, several techniques for deadlock freedom in MPST were defined.
Bettini~\etal~\cite{bettinicoppo08} follow a similar technique to Kobayashi's for the MPST setting. The main difference with our work is that we associate priorities with communication actions, whether Bettini~\etal~\cite{bettinicoppo08} with channels. Carbone and Montesi~\cite{carbonemontesi13} explore and combine MPST and choreographies to obtain a formalism that satisfies deadlock freedom by design.
Deni{\'{e}}lou and Yoshida \cite{DenielouY13} introduce the notion of \emph{multiparty compatibility} which generalises that of duality in binary session types and they synthesise safe and deadlock-free global types from local session types via the use of LTSs and communicating automata (CFSA).
Castellani~\etal~\cite{CastellaniDGH20} guarantee lock freedom--a stronger property than deadlock freedom--in the context of MPST with \emph{internal delegation}, where participants are allowed to delegate tasks to each other as long as they fall within the same multiparty session. This allows for the internal delegation to be captured by the global type.
Scalas and Yoshida \cite{scalasyoshida19} provide a revision of the theoretical foundations of MPST leading to a less complicated and more general theory, by completely removing the notion of duality/consistency. The type systems is parametric and ensures decidability of type checking, while allowing for a novel integration of model checking techniques in MPST. In this new theory, more protocols and processes can be typed that are guaranteed to be free of deadlocks. 

Gay~\etal~\cite{gaynagarajan03} and Vasconcelos~\etal~\cite{vasconcelosravara04,vasconcelosgay06} were the first to introduce a functional language with session types. However, such works, including early GV~\cite{gayvasconcelos10,gayvasconcelos12} did not guarantee deadlock freedom, until it was addressed via syntactic restrictions~\cite{lindleymorris15,wadler14}. Toninho~\etal~\cite{toninhocaires12} present a translation of simply-typed $\lambda$-calculus into session-typed $\pi$-calculus. However, their focus is not on deadlock freedom.

\subsubsection*{Ties with logic}
The correspondence between logic and types lays the foundation for functional programming~\cite{wadler15}. Since its inception by Girard~\cite{girard87}, linear logic has been a candidate for a foundational correspondence for concurrent programs. A~correspondence with linear $\pi$-calculus was established early on by Abramsky~\cite{abramsky94,bellinscott94}. A~correspondence between session-typed $\pi$-calculus and dual intuitionistic linear logic was developed by Caires and Pfenning~\cite[$\pi\text{DILL}$]{cairespfenning10}, and with classical linear logic by Wadler~\cite[CP]{wadler15}, both guaranteeing deadlock freedom as a result of their connection to logic. Dardha and Gay~\cite[PCP]{dardhagay18} integrate Kobayashi and Padovani's work on priorities~\cite{kobayashi06,padovani14} with CP, creating the first calculus which combines priorities and strong ties with logic. Dardha and P\'{e}rez~\cite{dardhaperez15} compare Kobayashi-style typing and CLL typing, and show that CLL corresponds to a subsystem of Kobayashi's where restriction is applied once. Balzer~\etal~\cite[$\text{SILL}_S$]{balzerpfenning17} introduce shared state, which breaks deadlock freedom. They later restore deadlock freedom using priorities~\cite[$\text{SILL}_{S+}$]{balzertoninho19}.
Carbone~\etal~\cite{CarboneMSY15,carbonelindley16} give a logical view of MPST with a generalised duality, called \emph{coherence}.

\subsubsection*{Conclusion and future work}
We answered our research question by presenting Priority GV, a~session-typed functional language which allows cyclic communication structures and uses priorities to ensure deadlock freedom. We showed its relation to Priority CP~\cite{dardhagay18} via an operational correspondence.

Our formalism so far only captures the core of GV. In future work, we plan to explore: recursion in PGV, by integrating the works of Lindley and Morris~\cite{lindleymorris16} and Padovani and Novara~\cite{padovaninovara15}; %a~translation from Priority GV to Priority CP;
and sharing, following Balzer and Pfenning~\cite{balzerpfenning17}.

\subsubsection*{Acknowledgement}
The authors would like to thank Simon Fowler, April Gon\c{c}alves, and Philip Wadler for their comments on the manuscript.

\end{document}
