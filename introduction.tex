% !TeX root = priorities.tex
\documentclass[main.tex]{subfiles}

\begin{document}
\section{Introduction}
Communication and concurrency are key in our modern society. Every service or device we interact with, from smart speakers, to health monitors or any other IoT device, relies on communication. Hence, specification and verification of communication in concurrent and distributed systems is paramount for our own safety. Session types are a type formalism which can be used to specify and verify communication protocols between two or more communicating agents in concurrent scenarios \cite{honda93,takeuchihonda94,hondavasconcelos98,carbonehonda07}.

Session types have been integrated in several programming paradigms, but to date the most successful settings remain the $\pi$-calculus \cite{sangiorgiwalker01} ---  a calculus for communication and concurrency, and GV (Good Variation) \cite{gayvasconcelos10,gayvasconcelos12} ---  a concurrent $\lambda$ calculus.
Session-typed concurrent $\lambda$-calculus or $\pi$-calculus satisfy safe communication and session fidelity, namely that communication proceeds without any mismatch and follows the predefined protocol specified by a session type. Another key property in a concurrent setting is deadlock freedom, meaning that agents communicate without getting stuck in cyclic dependencies. Unfortunately, deadlock freedom is a more involving property and session types alone are not enough to guarantee it.

Deadlock freedom in the $\pi$-calculus with or without session types has been extensively studied. A growing line of work is based on the Curry-Howard correspondences between linear logic and session-typed $\pi$-calculus \cite{cairespfenning10,wadler12}, which guarantee deadlock freedom by design. This is achieved by the cut rule, which merges together constructs for parallel composition and restriction thus forcing processes to share only one channel for communication and eliminates cyclic dependencies. Recent developments in the Classical Process \cite[CP]{wadler12} line of work have led to various approaches to decoupling these constructs, either while maintaining the strong correspondence to logic, as in Hypersequent CP~\cite[HCP]{kokkemontesi19popl,kokkemontesi19tlla}, or by weakening the correspondence to logic in exchange for a more expressive language, as in Priority CP~\cite[PCP]{dardhagay18}. PCP decouples CP's cut into separate constructs for name parallel composition --- by  introducing a mix rule, and restriction --- by introducing a cycle rule. Differently from previous work, PCP allows for cyclic structures and restores deadlock freedom by adding priorities following Kobayashi~\cite{kobayashi06} and Padovani \cite{padovani14}.

With regards to GV, the original work on session types in GV \cite{gayvasconcelos10,gayvasconcelos12} does not satisfy deadlock freedom. Later on, calculi in the GV family~\cite{wadler15,lindleymorris15} have achieved deadlock freedom via a syntactic restriction, i.e., by combining channel creation and thread spawning into a single operation, called fork, corresponding to the logical cut in CP, itself the combination of a name restriction and a parallel composition.
Unfortunately, this is overly restrictive, as it limits the possible communication structures to trees.
There are several benefits of working with a functional language as opposed to process calculi has its benefits: it supports higher-order functions (and therefore abstraction) not usually present in process calculi; and it allows us to derive extensions of the communication fragment of the language via well-understood extensions of the functional fragment, i.e., deriving internal/external choice from sum types. Moreover, the benefit of working with GV over other session-typed functional languages is that GV has strong ties to linear logic, via its relation to CP~\cite{wadler12}, and consequently it has strong formal properties, e.g., deadlock freedom, albeit in a restrictive way.

The above observations on GV together with the work on PCP led us to our research question:

\emph{Can we design a more expressive GV where deadlock freedom is guaranteed by design and communications structures are not limited to trees?}

We address this research question and by following the transition from CP to Priority CP, we presents 
Priority GV (PGV), a~variant of GV which decouples channel creation from thread creation, and restores deadlock freedom by adding priorities. This work closes the circle of CP and GV, their relation and their priority versions PCP and PGV.

\paragraph*{Contributions and Structure of the Paper}
\begin{itemize}
\item \textbf{PGV}: we present Priority GV in~\cref{sec:pgv}, the syntax of types and terms, operational semantics and typing rules. We prove subject reduction (\Cref{thm:pgv-subject-reduction-confs}) and closed progress (\Cref{lem:pgv-closed-progress-confs})
\item \textbf{Milner's Cyclic Scheduler}: We present Milner's Cyclic Scheduler \cite{milner89} \cref{sec:pgv-example} for the first time in GV.
\item \textbf{Updated PCP}: we present an updated version of PCP \cite{dardhagay18} where we remove the commuting conversions, moving away from reduction as cycle elimination, and towards reduction as one would expect for a process calculus. We report the Cyclic Scheduler from \cite{dardhagay18}.
\item \textbf{PCP into PGV}: We present an encoding of PCP into PGV and show that it is sound and complete with respect to typing (\Cref{thm:pcp-to-pgv-confs-preservation}) and semantics, by proving operational correspondence (\Cref{thm:pcp-to-pgv-operational-correspondence-soundness} and \Cref{thm:pcp-to-pgv-operational-correspondence-completeness}).
\end{itemize}
\end{document}