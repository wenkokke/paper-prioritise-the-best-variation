\documentclass[main.tex]{subfiles}

\begin{document}
\section{Introduction}
Session types have been studied for many programming paradigms, including concurrent and functional paradigms. In particular, \emph{binary} session types have been defined for the $\pi$-calculus~\cite{honda93,takeuchihonda94,hondavasconcelos98}---a process calculus for communication and concurrency; and later on for Good Variation (GV)~\cite{wadler15,lindleymorris15}---a linear concurrent $\lambda$-calculus.
Binary session types guarantee communication safety and session fidelity, namely that communication proceeds without any type mismatch and it follows the predefined protocol.
Another key property in a concurrent setting is \emph{deadlock freedom}, stating that agents communicate without getting stuck in cyclic dependencies. Deadlock freedom is a more involving property and binary session types \emph{alone} are not enough to rule out deadlocks in cyclic structures of different interleaved sessions. Several techniques have been developed to address deadlock freedom in session-typed $\pi$-calculus and concurrent $\lambda$-calculus.

With regards to $\pi$-calculus, a growing line of work leverages the Curry-Howard correspondences between session-typed $\pi$-calculus and intuitionistic~\cite{cairespfenning10} or classical linear logic~\cite{wadler14}, which guarantees deadlock freedom by restricting processes to only trees. The tree structure is achieved by merging constructs for parallel composition and channel restriction under the logical cut rule, which forces processes to share \emph{only one} channel for communication.
Recent developments in the CP~\cite{wadler14} line of work have led to various approaches to decoupling these constructs. One way is by maintaining a strong correspondence to classical linear logic and allowing only tree-structured processes, such as in Hypersequent CP (HCP)~\cite{kokkemontesi19popl,kokkemontesi19tlla}, Linear Compositional Choreographies (LCC)~\cite{CarboneMS18} or Classical Transitions (CT)~\cite{MP18}. Another way is by weakening the correspondence to classical linear logic in exchange for a more expressive language which allows cyclic-structured processes, such as in Priority CP (PCP)~\cite{dardhagay18}. PCP decouples CP's cut rule into two separate constructs: a construct for parallel composition, by introducing a mix rule; and a construct for restriction, by introducing a cycle rule. In order to restore deadlock freedom, PCP uses priorities following Kobayashi~\cite{kobayashi06} and Padovani~\cite{padovani14}. Priorities establish an \emph{order} of actions and are used to rule out bad interleavings of channels. By leveraging priorities, Dardha and Gay prove cycle-elimination of PCP (following the standard cut-elimination proof for classical linear logic). Deadlock freedom then follows as a corollary of the cycle-elimination result.

With regards to GV, the original work on session types in GV~\cite{gayvasconcelos12} did not satisfy deadlock freedom. Later on, calculi in the GV family~\cite{wadler15,lindleymorris15} have achieved deadlock freedom via a syntactic restriction, \ie by combining channel creation and thread spawning into a single operation, called fork. The fork construct is the term representation of the cut construct in CP, which as discussed above, evaluates to a channel restriction combined with a parallel composition. As with CP, this is restrictive because it limits process structures to only trees.

We aim to further investigate GV and deadlock freedom, as there are several benefits of working with a functional language as opposed to name-passing process calculi. Functional languages support higher-order functions, and have a capability for abstraction not usually present in process calculi. Working within a functional language allows to derive extensions of the communication capabilities of the language via well-understood extensions of the functional fragment, \ie deriving internal/external choice via sum types. In concurrent functional calculi, there is a clear separation between a program that the user writes, and a configuration, which is the state of a system as it evaluates. In process calculi, these are conflated. Finally, functional calculi bring us a step closer to transferring our work to real-world (functional) programming languages~\cite{KD21b}.
Moreover, the benefit of working with GV as opposed to other session-typed functional languages is that GV can be embedded in CP~\cite{wadler14}, and consequently it guarantees the same formal properties as CP, \eg deadlock freedom, albeit only for tree-structured processes.
Following the above observations, we thus pose our research question for GV.

\textbf{RQ:} \emph{Can we design a more expressive GV which guarantees deadlock freedom for cyclic-structured processes?}

We address this research question by following the line of work from CP to Priority CP, and present
Priority GV (PGV), a~variant of GV which decouples channel creation from thread spawning, thus allowing cyclic-structured processes and restores deadlock freedom via priorities. This closes the circle of the connection between CP and GV~\cite{wadler14}, and their priority-based versions, PCP~\cite{dardhagay18} and PGV.
In this paper we make the following contributions:
\begin{enumerate}
\item \textbf{Priority GV}. We present Priority GV (PGV) in~\cref{sec:pgv}, and prove subject reduction (\cref{thm:pgv-subject-reduction-confs}) and progress (\cref{thm:pgv-closed-progress-confs}).
PGV is the \emph{first} session-typed functional language with priorities \emph{and} strong ties to linear logic via its correspondence with PCP and its relation to the CP and GV languages.
\item \textbf{Solving GV problems}. PGV addresses several problems in the original GV language, most notably:
 	\begin{enumerate*}
	\item our version does not have the pseudo-type $S^\sharp$;
	\item our structural congruence is type preserving.
	\end{enumerate*}
\item \textbf{Updated Priority CP.} We present an updated version of Priority CP~\cite{dardhagay18} in \cref{sec:pcp}. We remove commuting conversions and move away from reduction as cut elimination, towards reduction based on structural congruence, as it is standard in process calculi.
\item \textbf{Connection to linear logic}. The connection of PGV to linear logic is given via a \emph{sound and complete encoding} of PCP to PGV in~\cref{sec:pcp}, where we prove the encoding preserves typing (\cref{thm:pcp-to-pgv-confs-preservation}) and satisfies operational correspondence (\cref{thm:pcp-to-pgv-operational-correspondence-soundness,thm:pcp-to-pgv-operational-correspondence-completeness}). We recall Milner's cyclic scheduler~\cite{milner89} presented in PCP~\cite{dardhagay18} and encode it in PGV.
\end{enumerate}
\end{document}
