% !TeX root = priorities.tex
\documentclass[main.tex]{subfiles}

\begin{document}
\section{Introduction}
Communication and concurrency are at the basis of our modern society. Every service or device we interact with, from smart phones, to health monitors or any other IoT device, relies on communication. Hence, verification of communication in concurrent settings is important for our own safety. Session types are a type formalism which can be used to specify and verify communication protocols between two or more communicating agents~\cite{honda93,takeuchihonda94,hondavasconcelos98,carbonehonda07}.
Session types have been studied for many programming paradigms, but to date the most successful settings remain the $\pi$-calculus~\cite{sangiorgiwalker01}---a process calculus for communication and concurrency, and Good Variation (GV)~\cite{wadler15,lindleymorris15}---a linear concurrent $\lambda$-calculus.
Session-typed concurrent $\lambda$-calculus and $\pi$-calculus satisfy communication safety and session fidelity, namely that communication proceeds without any type mismatch of the data being transmitted and follows the predefined protocol specified by a session type.
Another key property in a concurrent setting is deadlock freedom, stating that agents communicate without getting stuck in cyclic dependencies. Unfortunately, deadlock freedom is a more involving property and session types alone are not enough to rule out deadlocks in cyclic structures of multiple interleaved sessions. Several techniques have been developed to address deadlock freedom in the $\pi$-calculus and concurrent $\lambda$-calculus with session types.

With regards to $\pi$-calculus, a growing line of work on deadlock freedom leverages the Curry-Howard correspondences between intuitionistic or classical linear logic and session-typed $\pi$-calculus~\cite{cairespfenning10,wadler12}, which guarantee deadlock freedom by design. This is achieved by merging constructs for parallel composition and channel restriction under the logical cut rule, which forces processes to share only one channel for communication and eliminates cyclic dependencies. Recent developments in the Classical Process (CP)~\cite{wadler12} line of work have led to various approaches to decoupling these constructs, either by maintaining a strong correspondence to classical linear logic, as in Hypersequent CP~\cite{kokkemontesi19popl,kokkemontesi19tlla}, or by weakening the correspondence to classical linear logic in exchange for a more expressive language, as in Priority CP (PCP)~\cite{dardhagay18}. PCP decouples CP's cut rule into two separate constructs: a construct for parallel composition, by introducing a mix rule; and a construct for restriction, by introducing a cycle rule. Differently from previous work, PCP allows cyclic structures and restores deadlock freedom by adding priorities to types following Kobayashi~\cite{kobayashi06} and Padovani~\cite{padovani14}. Priorities establish an order of actions in a $\pi$-calculus process and are used to rule out bad interleaving of channels, guaranteeing deadlock freedom.

With regards to GV, the original work on session types in GV~\cite{gayvasconcelos10,gayvasconcelos12} did not satisfy deadlock freedom. Later on, calculi in the GV family~\cite{wadler15,lindleymorris15} have achieved deadlock freedom via a syntactic restriction, \ie by combining channel creation and thread spawning into a single operation, called fork. The fork construct is the term representation of the cut construct in CP, which evaluates to a channel restriction combined with a parallel composition. Unfortunately, as with CP, this is restrictive as it limits communication structures to trees. There are several benefits of working with a functional language as opposed to process calculi. Functional languages support higher-order functions, and have a capability for abstraction not usually present in process calculi. Working within a functional language allows to derive extensions of the communication capabilities of the language via well-understood extensions of the functional fragment, \ie deriving internal/external choice via sum types. Finally, in concurrent functional calculi, there is a clear separation between a program that the user writes, and a configuration, which is the state of a system as it evaluates. In process calculi, these are conflated.
Moreover, the benefit of working with GV over other session-typed functional languages is that GV has strong ties to linear logic, via its relation to CP~\cite{wadler12}, and consequently it has strong formal properties, \eg deadlock freedom, albeit in a restrictive way.
Following the above observations, we aim to further investigate GV and deadlock freedom, thus we pose our research question:

\emph{Can we design a more expressive GV where deadlock freedom is guaranteed by design and communication structures are not limited to trees?}

We address this research question by following the line of work from CP to Priority CP, and present
Priority GV (PGV), a~variant of GV which decouples channel creation from thread spawning and restores deadlock freedom by adding priorities. This work closes the circle of the strong connection of CP and GV, together with their priority versions, PCP and PGV.

We make the following contributions:
\begin{itemize}
\item \emph{Priority GV} We present Priority GV (PGV) in~\cref{sec:pgv}, and prove subject reduction (\cref{thm:pgv-subject-reduction-confs}) and progress (\cref{thm:pgv-closed-progress-confs}). Unlike  previous work on GV, structural congruence and reduction are type preserving in PGV.
\item \emph{Milner's Cyclic Scheduler} To illustrate newfound expressiveness of PGV, we present Milner's Cyclic Scheduler~\cite{milner89} (\cref{sec:pgv-example}).
\item \emph{Updated Priority CP} We present an updated version of Priority CP (PCP)~\cite{dardhagay18} in \cref{sec:pcp}. We remove commuting conversions and move away from reduction as cut elimination, towards reduction based on structural congruence, as one expects in a process calculus. We present Milner's Cyclic Scheduler in PCP (\cref{sec:pcp-example}).
\item \emph{Translation from PCP to PGV} We present a translation from PCP to PGV in~\cref{sec:pcp} and prove that it preserves typing (\cref{thm:pcp-to-pgv-confs-preservation}) and satisfies operational correspondence (\cref{thm:pcp-to-pgv-operational-correspondence-soundness,thm:pcp-to-pgv-operational-correspondence-completeness}). We show that the scheduler in PCP (\cref{sec:pcp-example}) translates to the scheduler in PGV (\cref{sec:pgv-example}).
\end{itemize}
\end{document}