% !TeX root = priorities.tex
\documentclass[main.tex]{subfiles}

\begin{document}
\section{Introduction}
Communication and concurrency are at the basis of our modern society. Every service or device we interact with, from smart phones, to health monitors or any other IoT devices, relies on communication. Hence, verification of communication in such concurrent scenarios is paramount for our own safety. Session types are a type formalism which can be used to specify and verify communication protocols between two or more communicating agents \cite{honda93,takeuchihonda94,hondavasconcelos98,carbonehonda07}.

Session types have been studied for many programming paradigms, but to date the most successful settings remain the $\pi$-calculus \cite{sangiorgiwalker01} ---  a calculus for communication and concurrency, and Good Variation \cite[GV]{wadler15,lindleymorris15} ---  a concurrent $\lambda$-calculus.
Session-typed concurrent $\lambda$-calculus and $\pi$-calculus satisfy communication safety and session fidelity, namely that communication proceeds without any type mismatch of the data being transmitted and follows the predefined protocol specified by a session type.
Another key property in a concurrent setting is deadlock freedom, stating that agents communicate without getting stuck in cyclic dependencies. Unfortunately, deadlock freedom is a more involving property and session types alone are not enough to guarantee it. Several techniques have been developed to address deadlock freedom in the $\pi$-calculus and concurrent $\lambda$-calculus with session types.

With regards to $\pi$-calculus, a growing line of work on deadlock freedom leverages the Curry-Howard correspondences between (intuitionistic or classical) linear logic and session-typed $\pi$-calculus \cite{cairespfenning10,wadler12}, which guarantee deadlock freedom by design. This is achieved by the cut rule, which merges together constructs for parallel composition and restriction thus forcing processes to share only one channel for communication and eliminating cyclic dependencies. Recent developments in the Classical Process \cite[CP]{wadler12} line of work have led to various approaches to decoupling these constructs, either by maintaining a strong correspondence to classical linear logic, as in Hypersequent CP~\cite[HCP]{kokkemontesi19popl,kokkemontesi19tlla}, or by weakening the correspondence to classical linear logic in exchange for a more expressive language, as in Priority CP~\cite[PCP]{dardhagay18}. PCP decouples CP's cut rule into two separate constructs, for parallel composition --- by  introducing a mix rule, and for restriction --- by introducing a cycle rule. Differently from previous work, PCP allows for cyclic structures and restores deadlock freedom by adding priorities to types following Kobayashi~\cite{kobayashi06} and Padovani \cite{padovani14}. Priorities capture the readiness of an action to fire, thus they establish an order of actions in a $\pi$-calculus process.

With regards to GV, the original work on session types in GV \cite{gayvasconcelos10,gayvasconcelos12} did not satisfy deadlock freedom. Later on, calculi in the GV family~\cite{wadler15,lindleymorris15} have achieved deadlock freedom via a syntactic restriction, i.e., by combining channel creation and thread spawning into a single operation, called fork. This corresponds to the logical cut rule in CP, which respectively is the combination of a name restriction and a parallel composition.
Unfortunately, as with CP, this is overly restrictive, as it limits the possible communication structures to trees.
There are several benefits of working with a functional language as opposed to process calculi: a functional language supports higher-order functions (and therefore abstraction) not usually present in process calculi; and it allows us to derive extensions of the communication fragment of the language via well-understood extensions of the functional fragment, i.e., deriving internal/external choice from sum types. Moreover, the benefit of working with GV over other session-typed functional languages is that GV has strong ties to linear logic, via its relation to CP~\cite{wadler12}, and consequently it has strong formal properties, e.g., deadlock freedom, albeit in a restrictive way.
Following the above observations, we aim to further investigate GV and deadlock freedom and thus pose our research question:

\emph{Can we design a more expressive GV where deadlock freedom is guaranteed by design and communication structures are not limited to trees?}

We address this research question by following the line of work from CP to Priority CP, and present
Priority GV (PGV), a~variant of GV which decouples channel creation from thread spawning, and restores deadlock freedom by adding priorities. This work closes the circle of the strong connection of CP and GV, together with their priority versions, PCP and PGV.

\subsubsection*{Contributions and Structure of the Paper}
\begin{itemize}
\item \emph{Priority GV} We present Priority GV (PGV) in~\Cref{sec:pgv}; we present the syntax of types and terms, operational semantics and typing rules. We show our type system for PGV is sound by proving subject reduction (\Cref{thm:pgv-subject-reduction-confs}) and closed progress (\Cref{lem:pgv-closed-progress-confs}).
\item \emph{Milner's Cyclic Scheduler in PGV} We present, for the first time, Milner's Cyclic Scheduler \cite{milner89} (\Cref{sec:pgv-example}) as a GV term. This example illustrates how a cyclic structure can now be expressed in PGV thanks to the separation of channel creation and thread creation, and priorities.
\item \emph{Updated Priority CP} We present an updated version of Priority CP (PCP) \cite{dardhagay18} in \Cref{sec:pcp} where we remove the commuting conversions and move away from a reduction relation as cycle elimination, and towards a reduction as one would expect for a process calculus. We then show Milner's Cyclic Scheduler in PCP (in \Cref{sec:pcp-example}) originally presented in \cite{dardhagay18}.
\item \emph{Encoding PCP into PGV} We present an encoding of PCP into PGV in \Cref{sec:pcp-to-pgv}. We prove the encoding is sound and complete with respect to typing (\Cref{thm:pcp-to-pgv-confs-preservation}) and operational semantics (\Cref{thm:pcp-to-pgv-operational-correspondence-soundness} and \Cref{thm:pcp-to-pgv-operational-correspondence-completeness}). Finally, we can encode Milner's Cyclic Scheduler in PCP (\Cref{sec:pcp-example}) resulting in the Scheduler in PGV (\Cref{sec:pgv-example}).
\end{itemize}
\end{document}