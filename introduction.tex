\documentclass[main.tex]{subfiles}

\begin{document}
\section{Introduction}
Session types have been studied for many programming paradigms, including concurrent and functional paradigms. In particular, \emph{binary} session types have been defined for the $\pi$-calculus~\cite{sangiorgiwalker01}---a process calculus for communication and concurrency---originally by Honda~\etal~\cite{honda93,takeuchihonda94,hondavasconcelos98}; and later on for Good Variation (GV)~\cite{wadler15,lindleymorris15}---a linear concurrent $\lambda$-calculus.
Binary session types guarantee communication safety and session fidelity, namely that communication proceeds without any type mismatch and it follows the predefined session protocol.
Another key property in a concurrent setting is \emph{deadlock freedom}, stating that agents communicate without getting stuck in cyclic dependencies. Deadlock freedom is a more involving property and binary session types \emph{alone} are not enough to rule out deadlocks in cyclic structures of different interleaved sessions. Several techniques have been developed to address deadlock freedom in the $\pi$-calculus and concurrent $\lambda$-calculus with session types, as detailed below.

With regards to $\pi$-calculus, a growing line of work on deadlock freedom leverages the Curry-Howard correspondences between intuitionistic or classical linear logic and the $\pi$-calculus with binary session types~\cite{cairespfenning10,wadler14}, which guarantees deadlock freedom by restricting the allowed processes to only trees. This is achieved by merging constructs for parallel composition and channel restriction under the logical cut rule, which forces processes to share \emph{only one} channel for communication, thus eliminating cyclic dependencies and deadlocks. Recent developments in the Classical Processes (CP)~\cite{wadler14} line of work have led to various approaches to decoupling these constructs. One way is by maintaining a strong correspondence to classical linear logic and allowing only tree-structured processes, such as in Hypersequent CP (HCP)~\cite{kokkemontesi19popl,kokkemontesi19tlla}, Linear Compositional Choreographies (LCC)~\cite{CarboneMS18} and Classical Transitions (CT)~\cite{MP18}. Another way is by weakening the correspondence to classical linear logic in exchange for a more expressive language where cyclic-structured processes are allowed, such as in Priority CP (PCP)~\cite{dardhagay18}. PCP decouples CP's cut rule into two separate constructs: a construct for parallel composition, by introducing a mix rule; and a construct for restriction, by introducing a cycle rule. This decoupling allows cyclic processes. In order to restore deadlock freedom, PCP uses priorities following Kobayashi~\cite{kobayashi06} and Padovani~\cite{padovani14}. Priorities establish an order of actions in a $\pi$-calculus process and are used to rule out bad interleavings of channels. Dardha and Gay prove cycle-elimination of PCP (following the standard cut-elimination proof) by leveraging priorities. Then, deadlock freedom follows as a result of the cycle-elimination proof.
%
With regards to GV, the original work on session types in GV~\cite{gayvasconcelos12} did not satisfy deadlock freedom. Later on, calculi in the GV family~\cite{wadler15,lindleymorris15} have achieved deadlock freedom via a syntactic restriction, \ie by combining channel creation and thread spawning into a single operation, called fork. The fork construct is the term representation of the cut construct in CP, which as mentioned above, evaluates to a channel restriction combined with a parallel composition. As with CP, this is restrictive because it limits process structures to only trees.

We aim to further investigate GV and deadlock freedom, as there are several benefits of working with a functional language as opposed to name-passing calculi. Functional languages support higher-order functions, and have a capability for abstraction not usually present in process calculi. Working within a functional language allows to derive extensions of the communication capabilities of the language via well-understood extensions of the functional fragment, \ie deriving internal/external choice via sum types. Finally, in concurrent functional calculi, there is a clear separation between a program that the user writes, and a configuration, which is the state of a system as it evaluates. In process calculi, these are conflated.
Moreover, the benefit of working with GV over other session-typed functional languages is that GV has strong ties to linear logic, via its relation to CP~\cite{wadler14}, and consequently it has strong formal properties, \eg deadlock freedom, albeit in a restrictive way.
Following the above observations, we thus pose our research question.

\textbf{RQ:} \emph{Can we design a more expressive GV where deadlock freedom is guaranteed by design and communication structures are not limited to only trees?}

We address this research question by following the line of work from CP to Priority CP, and present
Priority GV (PGV), a~variant of GV which decouples channel creation from thread spawning and restores deadlock freedom by adding priorities. This work closes the circle of the strong connection of CP and GV, together with their priority-based versions, PCP and PGV.

In this paper we make the following contributions:
\begin{enumerate}
\item \textbf{Priority GV}. We present Priority GV (PGV) in~\cref{sec:pgv}, and prove subject reduction (\cref{thm:pgv-subject-reduction-confs}) and progress (\cref{thm:pgv-closed-progress-confs}).
PGV is the \emph{first} session-typed functional language with priorities \emph{and} strong ties to linear logic via its correspondence with PCP and its relation to the CP and GV languages.
\item \textbf{Solving GV problems}. PGV addresses several problems in the original GV language, most notably:
 	\begin{enumerate*}
	\item our version does not have the pseudo-type $S^\sharp$;
	\item our structural congruence is type preserving.
	\end{enumerate*}
\item \textbf{Updated Priority CP.} We present an updated version of Priority CP~\cite{dardhagay18} in \cref{sec:pcp}. We remove commuting conversions and move away from reduction as cut elimination, towards reduction based on structural congruence, as it is standard in process calculi.
\item \textbf{Connection to linear logic}. The connection of PGV to linear logic is given via a \emph{sound and complete encoding} of PCP to PGV in~\cref{sec:pcp}, where we prove the encoding preserves typing (\cref{thm:pcp-to-pgv-confs-preservation}) and satisfies operational correspondence (\cref{thm:pcp-to-pgv-operational-correspondence-soundness,thm:pcp-to-pgv-operational-correspondence-completeness}). We recall Milner's cyclic scheduler~\cite{milner89} presented in PCP~\cite{dardhagay18} and encode it in PGV.
\end{enumerate}
\end{document}
