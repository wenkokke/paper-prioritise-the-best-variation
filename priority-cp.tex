\documentclass[main.tex]{subfiles}

\begin{document}

\section{Priority CP}
\usingnamespace{pcp}

\begin{figure}[t]
  \centering
  \includegraphics[width=0.8\columnwidth]{scheduler}
  \vspace{-4mm}
  \caption{Cyclic Scheduler from \cite{dardha2018}}
  \label{fig:scheduler}
  \vspace{-4mm}
  \end{figure}

\subsection{Syntax}

We present an updated version of Priority CP~\cite[PCP]{dardha2018}, which is Wadler's Classical Processes~\cite[CP]{wadler2012} with \emph{priorities}.
The main difference with respect to PCP by Dardha and Gay \cite{dardha2018} is moving away from a reduction strategy based on cycle elimination using commuting conversions, and towards a reduction strategy using structural congruence.

\paragraph*{Priorities, types, and environments}
Types are based on classical linear logic propositions, and are annotated with priorities ranging over $\cs{o}\in\mathbb{N}$. We let $\ty{A}, \ty{B}, \ty{C}$ range over types, produced by the following grammar.

The types $\ty{\tytens[\cs{o}]{A}{B}}$ and $\ty{\typarr[\cs{o}]{A}{B}}$ type the endpoints of a channel over which we send or receive a channel of type $\ty{A}$, and then proceed as type $\ty{B}$.
The types $\ty{\tyone[\cs{o}]}$ and $\ty{\tybot[\cs{o}]}$ type the endpoints of a channel whose session has terminated, and over which we send or receive a \emph{ping} before closing the channel. These two types act as units for $\ty{\tytens[\cs{o}]{A}{B}}$ and $\ty{\typarr[\cs{o}]{A}{B}}$, respectively.

The types $\ty{\typlus[\cs{o}]{A}{B}}$ and $\ty{\tywith[\cs{o}]{A}{B}}$ type the endpoints of a channel over which we can receive or send a choice between two branches $\ty{A}$ or $\ty{B}$. We have opted for a simplified version of choice and followed the original Wadler's CP \cite{wadler2012}, however types $\oplus$ and $\with$ can be trivially generalised to $\ty{\oplus^{\cs{o}}\{l_i:A_i\}_{i\in I}}$ and $\ty{\with^{\cs{o}}\{l_i:A_i\}_{i\in I}}$, respectively as in the original PCP \cite{dardha2018}.
The types $\ty{\tynil[\cs{o}]}$ and $\ty{\tytop[\cs{o}]}$ type the endpoints of a channel over which we can send or receive a choice between \emph{no options}. These two types act as units for $\ty{\typlus[\cs{o}]{A}{B}}$ and $\ty{\tywith[\cs{o}]{A}{B}}$, respectively.
\[
\begin{array}{lcl}
  \ty{A}, \ty{B}, \ty{C}
  & \coloneqq & \ty{\tytens[\cs{o}]{A}{B}}
    \sep        \ty{\typarr[\cs{o}]{A}{B}}
    \sep        \ty{\tyone[\cs{o}]}
    \sep        \ty{\tybot[\cs{o}]}
    \sep        \ty{\typlus[\cs{o}]{A}{B}}
    \sep        \ty{\tywith[\cs{o}]{A}{B}}
    \sep        \ty{\tynil[\cs{o}]}
    \sep        \ty{\tytop[\cs{o}]}
\end{array}
\]
A typing context $\ty\Gamma$ is a partial function associating channel names to types.
\[
\begin{array}{lcl}
  \ty{\Gamma}, \ty{\Delta}
  & \coloneqq & \ty{\emptyenv}
    \sep        \ty{\Gamma}, \tmty{x}{A}
\end{array}
\]
Duality on types is an involutive function which preserves the priorities of types.
\[
\begin{array}{lcl}
  \ty{\co{(\tyone[\cs{o}])}} & = & \ty{\tybot[\cs{o}]} \\
  \ty{\co{(\tybot[\cs{o}])}} & = & \ty{\tyone[\cs{o}]} \\
  \ty{\co{(\tynil[\cs{o}])}} & = & \ty{\tytop[\cs{o}]} \\
  \ty{\co{(\tytop[\cs{o}])}} & = & \ty{\tynil[\cs{o}]}
\end{array}
\qquad
\begin{array}{lcl}
  \ty{\co{(\tytens[\cs{o}]{A}{B})}} & = & \ty{\typarr[\cs{o}]{\co{A}}{\co{B}}} \\
  \ty{\co{(\typarr[\cs{o}]{A}{B})}} & = & \ty{\tytens[\cs{o}]{\co{A}}{\co{B}}} \\
  \ty{\co{(\typlus[\cs{o}]{A}{B})}} & = & \ty{\tywith[\cs{o}]{\co{A}}{\co{B}}} \\
  \ty{\co{(\tywith[\cs{o}]{A}{B})}} & = & \ty{\typlus[\cs{o}]{\co{A}}{\co{B}}}
\end{array}
\]
The function $\pr(\cdot)$ returns the priority of a type. The function $\minpr(\cdot)$ returns the \emph{minimum} priority of all types a typing context.
\[
\begin{array}{lclclcl}
  \pr(\ty{\tyone[\cs{o}]})        & = & \cs{o}  \\
  \pr(\ty{\tybot[\cs{o}]})        & = & \cs{o}  \\
  \pr(\ty{\tynil[\cs{o}]})        & = & \cs{o}  \\
  \pr(\ty{\tytop[\cs{o}]})        & = & \cs{o}  \\
  \\
  \minpr(\ty{\emptyenv})          & = & \varnothing
\end{array}
\qquad
\begin{array}{lclclcl}
  \pr(\ty{\tytens[\cs{o}]{A}{B}}) & = & \cs{o}  \\
  \pr(\ty{\typarr[\cs{o}]{A}{B}}) & = & \cs{o}  \\
  \pr(\ty{\typlus[\cs{o}]{A}{B}}) & = & \cs{o}  \\
  \pr(\ty{\tywith[\cs{o}]{A}{B}}) & = & \cs{o}  \\
  \\
  \minpr(\ty{\Gamma},\tmty{x}{A}) & = & \minpr(\ty{\Gamma})\sqcap\minpr(\ty{A})
\end{array}
\]

\paragraph*{Terms}
We let $\tm{P}, \tm{Q}$ range over processes, produced by the following grammar.

Process $\tm{\link{x}{y}}$ links channels $x$ and $y$ and forwards communication from one to the other. Processes $\tm{\res{x}{y}{P}}$, $\tm{(\ppar{P}{Q})}$ and $\tm{\halt}$ denote respectively the restriction processes where channel endpoints $\tm x$ and $\tm y$ are bound together and with scope $\tm P$, the parallel composition of processes $\tm{P}$ and $\tm{Q}$ and the terminated process.

Processes $\tm{\send{x}{y}{P}}$ and $\tm{\recv{x}{y}{P}}$ send or receive over channel $\tm x$ a value $\tm y$ and proceed as process $\tm P$. Processes $\tm{\close{x}{P}}$ and $\tm{\wait{x}{P}}$ send and receive an empty value -- denoting the closure of channel $\tm x$, and continue as $\tm P$.

Processes $\tm{\inl{x}{P}}$ and $\tm{\inr{x}{P}}$ make a left and right choice, respectively and proceed as process $\tm P$. Process $\tm{\offer{x}{P}{Q}}$ dually offers both left and right branches, with continuations $\tm P$ and $\tm Q$. Process $\tm{\absurd{x}}$ denotes the empty offer.

\[
\begin{array}[t]{lcl}
  \tm{P}, \tm{Q}
  & \coloneqq & \tm{\link{x}{y}}
         \sep   \tm{\res{x}{y}{P}}
         \sep   \tm{(\ppar{P}{Q})}
         \sep   \tm{\halt}
  \\   & \sep & \tm{\send{x}{y}{P}}
         \sep   \tm{\close{x}{P}}
         \sep   \tm{\recv{x}{y}{P}}
         \sep   \tm{\wait{x}{P}}
  \\   & \sep & \tm{\inl{x}{P}}
         \sep   \tm{\inr{x}{P}}
         \sep   \tm{\offer{x}{P}{Q}}
         \sep   \tm{\absurd{x}}
\end{array}
\]
\paragraph*{Syntactic Sugar}
We define \emph{unbound} send:
\[
  \tm{\usend{x}{y}{P}}\elabarrow\tm{\send{x}{z}{(\ppar{\link{y}{z}}{P})}}
\]

\subsection{Typing}
See \cref{fig:pcp-typing}.
\input{fig/pcp-typing}

\subsection{Operational Semantics}
See \cref{fig:pcp-operational-semantics}.
\input{fig/pcp-operational-semantics}

\subsection{Metatheory}

\begin{restatablelemma}{lempcpsubjectcongruence}[Subject Congruence, $\equiv$]
  \label{lem:pcp-subject-congruence}
  \hfill\\%newline before theorem statement
  If $\seq{P}{\ty{\Gamma}}$ and $\tm{P}\equiv\tm{Q}$,
  then $\seq{Q}{\ty{\Gamma}}$.
\end{restatablelemma}
\begin{proof}
  See~\cite{dardha2018}.
\end{proof}

\begin{restatabletheorem}{thmpcpsubjectreduction}[Subject Reduction, $\red$]
  \label{thm:pcp-subject-reduction}
  \hfill\\%newline before theorem statement
  If $\seq{P}{\ty{\Gamma}}$ and $\tm{P}\red\tm{Q}$, then $\seq{Q}{\ty{\Gamma}}$.
\end{restatabletheorem}
\begin{proof}
  See~\cite{dardha2018}.
\end{proof}

\begin{definition}[Actions]
  A~process acts on an endpoint $\tm{x}$ if it is in one of the following forms:
  \begin{multicols}{3}
    \begin{itemize}[noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt]
    \item $\tm{\link{x}{y}}$ 
    \item $\tm{\link{y}{x}}$
    \item $\tm{\send{x}{y}{P}}$
    \item $\tm{\recv{x}{y}{P}}$
    \item $\tm{\close{x}{P}}$
    \item $\tm{\wait{x}{P}}$
    \item $\tm{\inl{x}{P}}$
    \item $\tm{\inr{x}{P}}$
    \item $\tm{\offer{x}{P}{Q}}$
    \item $\tm{\absurd{x}}$
    \end{itemize}
  \end{multicols}
  \noindent
  A~process is an action if it acts on on some endpoint $\tm{x}$.
\end{definition}

\begin{definition}[Canonical Forms]
  \label{def:pcp-canonical-forms}
  A~process $\tm{P}$ is in canonical form if it is in one of the following forms:
  \begin{itemize}[noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt]
  \item
    $\tm{\halt}$
  \item
    $\tm{\res{x_1}{x'_1}{\dots\res{x_n}{x'_n}{(P_1 \parallel\dots\parallel P_m)}}}$
    where $m>0$ and each $\tm{P_j}$ is an action.
  \end{itemize}
\end{definition}

\begin{restatablelemma}{lempcpcanonicalforms}[Canonical Forms]
  \label{lem:pcp-canonical-forms}
  If $\seq{P}{\ty{\Gamma}}$, there exists some $\tm{Q}$ such that $\tm{P}\equiv\tm{Q}$ and $\tm{Q}$ is in canonical form.
\end{restatablelemma}
\begin{proof}
  If $\tm{P}=\tm{\halt}$, we are done. Otherwise, we move any $\nu$-binders to the top using \LabTirName{SC-ResExt}, and discard any superfluous occurrences of $\tm{\halt}$ using \LabTirName{SC-ParNil}.
\end{proof}

\begin{restatabletheorem}{thmpcpclosedprogress}[Closed Progress, $\red$]
  \label{thm:pcp-closed-progress}
  \hfill\\%newline before theorem statement
  If $\seq{P}{\emptyenv}$ and $\tm{P}$ is in canonical form, then either $\tm{P}=\tm{\halt}$ or there exists a $\tm{Q}$ such that $\tm{P}\red\tm{Q}$.
\end{restatabletheorem}
\begin{proof}
  Details in~\cref{prf:thm-pcp-closed-progress}.
\end{proof}

\end{document}

%%% Local Variables:
%%% TeX-master: "priorities"
%%% End:
